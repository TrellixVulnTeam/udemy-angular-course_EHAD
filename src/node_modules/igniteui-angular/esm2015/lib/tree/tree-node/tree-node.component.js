import { AnimationBuilder } from '@angular/animations';
import { Component, Input, Inject, ViewChild, TemplateRef, ContentChildren, Optional, SkipSelf, HostBinding, ElementRef, ChangeDetectorRef, Output, EventEmitter, Directive, HostListener } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { ToggleAnimationPlayer } from '../../expansion-panel/toggle-animation-component';
import { IGX_TREE_COMPONENT, IGX_TREE_NODE_COMPONENT, IgxTreeSelectionType } from '../common';
import { IgxTreeSelectionService } from '../tree-selection.service';
import { IgxTreeNavigationService } from '../tree-navigation.service';
import { IgxTreeService } from '../tree.service';
import { CurrentResourceStrings } from '../../core/i18n/resources';
import { DisplayDensity } from '../../core/displayDensity';
// TODO: Implement aria functionality
/**
 * @hidden @internal
 * Used for links (`a` tags) in the body of an `igx-tree-node`. Handles aria and event dispatch.
 */
export class IgxTreeNodeLinkDirective {
    constructor(node, navService, elementRef) {
        this.node = node;
        this.navService = navService;
        this.elementRef = elementRef;
        this.role = 'treeitem';
        this._parentNode = null;
    }
    /**
     * The node's parent. Should be used only when the link is defined
     * in `<ng-template>` tag outside of its parent, as Angular DI will not properly provide a reference
     *
     * ```html
     * <igx-tree>
     *     <igx-tree-node #myNode *ngFor="let node of data" [data]="node">
     *         <ng-template *ngTemplateOutlet="nodeTemplate; context: { $implicit: data, parentNode: myNode }">
     *         </ng-template>
     *     </igx-tree-node>
     *     ...
     *     <!-- node template is defined under tree to access related services -->
     *     <ng-template #nodeTemplate let-data let-node="parentNode">
     *         <a [igxTreeNodeLink]="node">{{ data.label }}</a>
     *     </ng-template>
     * </igx-tree>
     * ```
     */
    set parentNode(val) {
        if (val) {
            this._parentNode = val;
            this._parentNode.addLinkChild(this);
        }
    }
    get parentNode() {
        return this._parentNode;
    }
    /** A pointer to the parent node */
    get target() {
        return this.node || this.parentNode;
    }
    /** @hidden @internal */
    get tabIndex() {
        var _a;
        return this.navService.focusedNode === this.target ? (((_a = this.target) === null || _a === void 0 ? void 0 : _a.disabled) ? -1 : 0) : -1;
    }
    /**
     * @hidden @internal
     * Clear the node's focused state
     */
    handleBlur() {
        this.target.isFocused = false;
    }
    /**
     * @hidden @internal
     * Set the node as focused
     */
    handleFocus() {
        if (this.target && !this.target.disabled) {
            if (this.navService.focusedNode !== this.target) {
                this.navService.focusedNode = this.target;
            }
            this.target.isFocused = true;
        }
    }
    ngOnDestroy() {
        this.target.removeLinkChild(this);
    }
}
IgxTreeNodeLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: `[igxTreeNodeLink]`
            },] }
];
IgxTreeNodeLinkDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [IGX_TREE_NODE_COMPONENT,] }] },
    { type: IgxTreeNavigationService },
    { type: ElementRef }
];
IgxTreeNodeLinkDirective.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    parentNode: [{ type: Input, args: ['igxTreeNodeLink',] }],
    tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    handleBlur: [{ type: HostListener, args: ['blur',] }],
    handleFocus: [{ type: HostListener, args: ['focus',] }]
};
/**
 *
 * The tree node component represents a child node of the tree component or another tree node.
 * Usage:
 *
 * ```html
 *  <igx-tree>
 *  ...
 *    <igx-tree-node [data]="data" [selected]="service.isNodeSelected(data.Key)" [expanded]="service.isNodeExpanded(data.Key)">
 *      {{ data.FirstName }} {{ data.LastName }}
 *    </igx-tree-node>
 *  ...
 *  </igx-tree>
 * ```
 */
export class IgxTreeNodeComponent extends ToggleAnimationPlayer {
    constructor(tree, selectionService, treeService, navService, cdr, builder, element, parentNode) {
        super(builder);
        this.tree = tree;
        this.selectionService = selectionService;
        this.treeService = treeService;
        this.navService = navService;
        this.cdr = cdr;
        this.builder = builder;
        this.element = element;
        this.parentNode = parentNode;
        /**
         * To be used for load-on-demand scenarios in order to specify whether the node is loading data.
         *
         * @remarks
         * Loading nodes do not render children.
         */
        this.loading = false;
        /**
         * Emitted when the node's `selected` property changes.
         *
         * ```html
         * <igx-tree>
         *      <igx-tree-node *ngFor="let node of data" [data]="node" [(selected)]="node.selected">
         *      </igx-tree-node>
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
         * node.selectedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log("Node selection changed to ", e))
         * ```
         */
        this.selectedChange = new EventEmitter();
        /**
         * Emitted when the node's `expanded` property changes.
         *
         * ```html
         * <igx-tree>
         *      <igx-tree-node *ngFor="let node of data" [data]="node" [(expanded)]="node.expanded">
         *      </igx-tree-node>
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
         * node.expandedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log("Node expansion state changed to ", e))
         * ```
         */
        this.expandedChange = new EventEmitter();
        /** @hidden @internal */
        this.cssClass = 'igx-tree-node';
        /** @hidden @internal */
        this.registeredChildren = [];
        /** @hidden @internal */
        this._resourceStrings = CurrentResourceStrings.TreeResStrings;
        this._tabIndex = null;
        this._disabled = false;
    }
    // TO DO: return different tab index depending on anchor child
    /** @hidden @internal */
    set tabIndex(val) {
        this._tabIndex = val;
    }
    /** @hidden @internal */
    get tabIndex() {
        if (this.disabled) {
            return -1;
        }
        if (this._tabIndex === null) {
            if (this.navService.focusedNode === null) {
                return this.hasLinkChildren ? -1 : 0;
            }
            return -1;
        }
        return this.hasLinkChildren ? -1 : this._tabIndex;
    }
    /** @hidden @internal */
    get animationSettings() {
        return this.tree.animationSettings;
    }
    /**
     * Gets/Sets the resource strings.
     *
     * @remarks
     * Uses EN resources by default.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        if (!this._resourceStrings) {
            this._resourceStrings = CurrentResourceStrings.TreeResStrings;
        }
        return this._resourceStrings;
    }
    /**
     * Gets/Sets the active state of the node
     *
     * @param value: boolean
     */
    set active(value) {
        if (value) {
            this.navService.activeNode = this;
            this.tree.activeNodeBindingChange.emit(this);
        }
    }
    get active() {
        return this.navService.activeNode === this;
    }
    /** @hidden @internal */
    get focused() {
        return this.isFocused &&
            this.navService.focusedNode === this;
    }
    /**
     * Retrieves the full path to the node incuding itself
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const path: IgxTreeNode<any>[] = node.path;
     * ```
     */
    get path() {
        var _a;
        return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.path) ? [...this.parentNode.path, this] : [this];
    }
    // TODO: bind to disabled state when node is dragged
    /**
     * Gets/Sets the disabled state of the node
     *
     * @param value: boolean
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = value;
            this.tree.disabledChange.emit(this);
        }
    }
    /** @hidden @internal */
    get role() {
        return this.hasLinkChildren ? 'none' : 'treeitem';
    }
    ;
    /**
     * Return the child nodes of the node (if any)
     *
     * @remark
     * Returns `null` if node does not have children
     *
     * @example
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const children: IgxTreeNode<any>[] = node.children;
     * ```
     */
    get children() {
        var _a;
        return ((_a = this._children) === null || _a === void 0 ? void 0 : _a.length) ? this._children.toArray() : null;
    }
    get hasLinkChildren() {
        var _a, _b;
        return ((_a = this.linkChildren) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = this.registeredChildren) === null || _b === void 0 ? void 0 : _b.length) > 0;
    }
    /** @hidden @internal */
    get isCompact() {
        var _a;
        return ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.displayDensity) === DisplayDensity.compact;
    }
    /** @hidden @internal */
    get isCosy() {
        var _a;
        return ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.displayDensity) === DisplayDensity.cosy;
    }
    /**
     * @hidden @internal
     */
    get showSelectors() {
        return this.tree.selection !== IgxTreeSelectionType.None;
    }
    /**
     * @hidden @internal
     */
    get indeterminate() {
        return this.selectionService.isNodeIndeterminate(this);
    }
    /** The depth of the node, relative to the root
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node #node>
     *      My level is {{ node.level }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[12])[0];
     * const level: number = node.level;
     * ```
     */
    get level() {
        return this.parentNode ? this.parentNode.level + 1 : 0;
    }
    /** Get/set whether the node is selected. Supporst two-way binding.
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node *ngFor="let node of data" [(selected)]="node.selected">
     *      {{ node.label }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const selected = node.selected;
     * node.selected = true;
     * ```
     */
    get selected() {
        return this.selectionService.isNodeSelected(this);
    }
    set selected(val) {
        var _a;
        if (!(((_a = this.tree) === null || _a === void 0 ? void 0 : _a.nodes) && this.tree.nodes.find((e) => e === this)) && val) {
            this.tree.forceSelect.push(this);
            return;
        }
        if (val && !this.selectionService.isNodeSelected(this)) {
            this.selectionService.selectNodesWithNoEvent([this]);
        }
        if (!val && this.selectionService.isNodeSelected(this)) {
            this.selectionService.deselectNodesWithNoEvent([this]);
        }
    }
    /** Get/set whether the node is expanded
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node *ngFor="let node of data" [expanded]="node.name === this.expandedNode">
     *      {{ node.label }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const expanded = node.expanded;
     * node.expanded = true;
     * ```
     */
    get expanded() {
        return this.treeService.isExpanded(this);
    }
    set expanded(val) {
        if (val) {
            this.treeService.expand(this, false);
        }
        else {
            this.treeService.collapse(this);
        }
    }
    /** @hidden @internal */
    get expandIndicatorTemplate() {
        var _a;
        return ((_a = this.tree) === null || _a === void 0 ? void 0 : _a.expandIndicator) ? this.tree.expandIndicator : this._defaultExpandIndicatorTemplate;
    }
    /**
     * The native DOM element representing the node. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second node
     * const node: IgxTreeNode = this.tree.nodes.first();
     * const nodeElement: HTMLElement = node.nativeElement;
     * ```
     */
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    ngOnInit() {
        this.openAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.tree.nodeExpanded.emit({ owner: this.tree, node: this });
        });
        this.closeAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.tree.nodeCollapsed.emit({ owner: this.tree, node: this });
            this.treeService.collapse(this);
            this.cdr.markForCheck();
        });
    }
    /** @hidden @internal */
    ngAfterViewInit() { }
    /**
     * @hidden @internal
     * Sets the focus to the node's <a> child, if present
     * Sets the node as the tree service's focusedNode
     * Marks the node as the current active element
     */
    handleFocus() {
        var _a;
        if (this.disabled) {
            return;
        }
        if (this.navService.focusedNode !== this) {
            this.navService.focusedNode = this;
        }
        this.isFocused = true;
        if ((_a = this.linkChildren) === null || _a === void 0 ? void 0 : _a.length) {
            this.linkChildren.first.nativeElement.focus();
            return;
        }
        if (this.registeredChildren.length) {
            this.registeredChildren[0].elementRef.nativeElement.focus();
            return;
        }
    }
    /**
     * @hidden @internal
     * Clear the node's focused status
     */
    clearFocus() {
        this.isFocused = false;
    }
    /**
     * @hidden @internal
     */
    onSelectorClick(event) {
        // event.stopPropagation();
        event.preventDefault();
        // this.navService.handleFocusedAndActiveNode(this);
        if (event.shiftKey) {
            this.selectionService.selectMultipleNodes(this, event);
            return;
        }
        if (this.selected) {
            this.selectionService.deselectNode(this, event);
        }
        else {
            this.selectionService.selectNode(this, event);
        }
    }
    /**
     * Toggles the node expansion state, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button igxButton (click)="node.toggle()">Toggle Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.toggle();
     * ```
     */
    toggle() {
        if (this.expanded) {
            this.collapse();
        }
        else {
            this.expand();
        }
    }
    /** @hidden @internal */
    indicatorClick() {
        this.toggle();
        this.navService.setFocusedAndActiveNode(this);
    }
    /**
     * @hidden @internal
     */
    onPointerDown(event) {
        event.stopPropagation();
        this.navService.setFocusedAndActiveNode(this);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.selectionService.ensureStateOnNodeDelete(this);
    }
    /**
     * Expands the node, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button igxButton (click)="node.expand()">Expand Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.expand();
     * ```
     */
    expand() {
        const args = {
            owner: this.tree,
            node: this,
            cancel: false
        };
        this.tree.nodeExpanding.emit(args);
        if (!args.cancel) {
            this.treeService.expand(this, true);
            this.cdr.detectChanges();
            this.playOpenAnimation(this.childrenContainer);
        }
    }
    /**
     * Collapses the node, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button igxButton (click)="node.collapse()">Collapse Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.collapse();
     * ```
     */
    collapse() {
        const args = {
            owner: this.tree,
            node: this,
            cancel: false
        };
        this.tree.nodeCollapsing.emit(args);
        if (!args.cancel) {
            this.treeService.collapsing(this);
            this.playCloseAnimation(this.childrenContainer);
        }
    }
    /** @hidden @internal */
    addLinkChild(link) {
        this._tabIndex = -1;
        this.registeredChildren.push(link);
    }
    ;
    /** @hidden @internal */
    removeLinkChild(link) {
        const index = this.registeredChildren.indexOf(link);
        if (index !== -1) {
            this.registeredChildren.splice(index, 1);
        }
    }
}
IgxTreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tree-node',
                template: "<ng-template #noDragTemplate>\n    <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n</ng-template>\n\n<!-- Will switch templates depending on dragDrop -->\n<ng-template *ngTemplateOutlet=\"noDragTemplate\">\n</ng-template>\n\n<div #childrenContainer\n    *ngIf=\"expanded && !loading\"\n    class=\"igx-tree-node__group\"\n    role=\"group\"\n>\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n\n\n<ng-template #defaultIndicator>\n    <igx-icon [attr.aria-label]=\"expanded ? resourceStrings.igx_collapse : resourceStrings.igx_expand\">\n        {{ expanded ? \"keyboard_arrow_down\" : \"keyboard_arrow_right\" }}\n    </igx-icon>\n</ng-template>\n\n<!-- separated in a template in case this ever needs to be templatable -->\n<ng-template #selectMarkerTemplate>\n    <igx-checkbox [checked]=\"selected\" [readonly]=\"true\" [indeterminate]=\"indeterminate\" [tabindex]=\"-1\">\n    </igx-checkbox>\n</ng-template>\n\n<ng-template #headerTemplate>\n    <div #ghostTemplate class=\"igx-tree-node__wrapper\"\n        [attr.role]=\"role\"\n        [tabIndex]=\"tabIndex\"\n        [ngClass]=\"{\n            'igx-tree-node__wrapper--cosy': isCosy,\n            'igx-tree-node__wrapper--compact': isCompact,\n            'igx-tree-node__wrapper--selected': selected,\n            'igx-tree-node__wrapper--active' : this.active,\n            'igx-tree-node__wrapper--focused' : this.focused,\n            'igx-tree-node__wrapper--disabled' : this.disabled\n        }\"\n        (pointerdown)=\"onPointerDown($event)\"\n        (focus)=\"handleFocus()\"\n        (blur)=\"clearFocus()\"\n    >\n        <div aria-hidden=\"true\">\n            <span *ngFor=\"let item of [].constructor(level)\"\n                aria-hidden=\"true\"\n                class=\"igx-tree-node__spacer\"\n            ></span>\n        </div>\n\n        <!-- Expand/Collapse indicator -->\n        <span *ngIf=\"!loading\"\n            class=\"igx-tree-node__toggle-button\"\n            [ngClass]=\"{ 'igx-tree-node__toggle-button--hidden': !_children?.length }\"\n            (click)=\"indicatorClick()\"\n        >\n            <ng-container *ngTemplateOutlet=\"expandIndicatorTemplate, context: { $implicit: expanded }\">\n            </ng-container>\n        </span>\n        <span *ngIf=\"loading\"\n            class=\"igx-tree-node__toggle-button\"\n        >\n        \t<igx-circular-bar\n            \t[animate]=\"false\"\n            \t[indeterminate]=\"true\"\n            \t[textVisibility]=\"false\"\n        \t>\n        \t</igx-circular-bar>\n        </span>\n\n        <!-- Item selection -->\n        <div *ngIf=\"showSelectors\"\n            class=\"igx-tree-node__select\"\n            (pointerdown)=\"$event.preventDefault()\"\n            (click)=\"onSelectorClick($event)\">\n            <ng-container *ngTemplateOutlet=\"selectMarkerTemplate\">\n            </ng-container>\n        </div>\n\n        <div class=\"igx-tree-node__content\">\n            <!-- Ghost content -->\n            <ng-content></ng-content>\n        </div>\n    </div>\n\n    <!--  Buffer element for 'move after' when D&D is implemented-->\n    <div class=\"igx-tree-node__drop-indicator\">\n        <span aria-hidden=\"true\" class=\"igx-tree-node__spacer\" *ngFor=\"let item of [].constructor(level)\"></span>\n        <!-- style rules target this div, do not delete it -->\n        <div></div>\n    </div>\n</ng-template>\n\n<ng-template #dragTemplate>\n    <!-- Drag drop goes here\n        igxDrop\n        #dropRef=\"drop\"\n        [igxNodeDrag]=\"this\"\n        (dragStart)=\"logDrop(dropRef)\"\n        (leave)=\"emitLeave()\"\n        (enter)=\"emitEnter()\" -->\n    <div class=\"igx-tree-node__drag-wrapper\">\n        <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n    </div>\n</ng-template>\n",
                providers: [
                    { provide: IGX_TREE_NODE_COMPONENT, useExisting: IgxTreeNodeComponent }
                ]
            },] }
];
IgxTreeNodeComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TREE_COMPONENT,] }] },
    { type: IgxTreeSelectionService },
    { type: IgxTreeService },
    { type: IgxTreeNavigationService },
    { type: ChangeDetectorRef },
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [IGX_TREE_NODE_COMPONENT,] }] }
];
IgxTreeNodeComponent.propDecorators = {
    data: [{ type: Input }],
    loading: [{ type: Input }],
    resourceStrings: [{ type: Input }],
    active: [{ type: Input }],
    selectedChange: [{ type: Output }],
    expandedChange: [{ type: Output }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.igx-tree-node--disabled',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-tree-node',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    linkChildren: [{ type: ContentChildren, args: [IgxTreeNodeLinkDirective, { read: ElementRef },] }],
    _children: [{ type: ContentChildren, args: [IGX_TREE_NODE_COMPONENT, { read: IGX_TREE_NODE_COMPONENT },] }],
    allChildren: [{ type: ContentChildren, args: [IGX_TREE_NODE_COMPONENT, { read: IGX_TREE_NODE_COMPONENT, descendants: true },] }],
    header: [{ type: ViewChild, args: ['ghostTemplate', { read: ElementRef },] }],
    _defaultExpandIndicatorTemplate: [{ type: ViewChild, args: ['defaultIndicator', { read: TemplateRef, static: true },] }],
    childrenContainer: [{ type: ViewChild, args: ['childrenContainer', { read: ElementRef },] }],
    selected: [{ type: Input }],
    expanded: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi90cmVlL3RyZWUtbm9kZS90cmVlLW5vZGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFDSCxTQUFTLEVBQ0UsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUE0QixlQUFlLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFDL0csV0FBVyxFQUNYLFVBQVUsRUFDVixpQkFBaUIsRUFDakIsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEVBQ1QsWUFBWSxFQUNmLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUscUJBQXFCLEVBQTJCLE1BQU0sa0RBQWtELENBQUM7QUFDbEgsT0FBTyxFQUNILGtCQUFrQixFQUNsQix1QkFBdUIsRUFBOEIsb0JBQW9CLEVBQzVFLE1BQU0sV0FBVyxDQUFDO0FBQ25CLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUVqRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFM0QscUNBQXFDO0FBQ3JDOzs7R0FHRztBQUlILE1BQU0sT0FBTyx3QkFBd0I7SUEwQ2pDLFlBQ1EsSUFBc0IsRUFDbEIsVUFBb0MsRUFDckMsVUFBc0I7UUFGekIsU0FBSSxH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RUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQ0FHakUsU0FBUyxTQUFDLG1CQUFtQixFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRTt1QkE2Rm5ELEtBQUs7dUJBbUNMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbmltYXRpb25CdWlsZGVyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICAgIENvbXBvbmVudCwgT25Jbml0LFxuICAgIE9uRGVzdHJveSwgSW5wdXQsIEluamVjdCwgVmlld0NoaWxkLCBUZW1wbGF0ZVJlZiwgQWZ0ZXJWaWV3SW5pdCwgUXVlcnlMaXN0LCBDb250ZW50Q2hpbGRyZW4sIE9wdGlvbmFsLCBTa2lwU2VsZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBFbGVtZW50UmVmLFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgRGlyZWN0aXZlLFxuICAgIEhvc3RMaXN0ZW5lclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRvZ2dsZUFuaW1hdGlvblBsYXllciwgVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9leHBhbnNpb24tcGFuZWwvdG9nZ2xlLWFuaW1hdGlvbi1jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBJR1hfVFJFRV9DT01QT05FTlQsIElneFRyZWUsIElneFRyZWVOb2RlLFxuICAgIElHWF9UUkVFX05PREVfQ09NUE9ORU5ULCBJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncywgSWd4VHJlZVNlbGVjdGlvblR5cGVcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJlZS1zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmVlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VydmljZSB9IGZyb20gJy4uL3RyZWUuc2VydmljZSc7XG5pbXBvcnQgeyBJVHJlZVJlc291cmNlU3RyaW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvaTE4bi90cmVlLXJlc291cmNlcyc7XG5pbXBvcnQgeyBDdXJyZW50UmVzb3VyY2VTdHJpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9pMThuL3Jlc291cmNlcyc7XG5pbXBvcnQgeyBEaXNwbGF5RGVuc2l0eSB9IGZyb20gJy4uLy4uL2NvcmUvZGlzcGxheURlbnNpdHknO1xuXG4vLyBUT0RPOiBJbXBsZW1lbnQgYXJpYSBmdW5jdGlvbmFsaXR5XG4vKipcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKiBVc2VkIGZvciBsaW5rcyAoYGFgIHRhZ3MpIGluIHRoZSBib2R5IG9mIGFuIGBpZ3gtdHJlZS1ub2RlYC4gSGFuZGxlcyBhcmlhIGFuZCBldmVudCBkaXNwYXRjaC5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBbaWd4VHJlZU5vZGVMaW5rXWBcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICd0cmVlaXRlbSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSdzIHBhcmVudC4gU2hvdWxkIGJlIHVzZWQgb25seSB3aGVuIHRoZSBsaW5rIGlzIGRlZmluZWRcbiAgICAgKiBpbiBgPG5nLXRlbXBsYXRlPmAgdGFnIG91dHNpZGUgb2YgaXRzIHBhcmVudCwgYXMgQW5ndWxhciBESSB3aWxsIG5vdCBwcm9wZXJseSBwcm92aWRlIGEgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICA8aWd4LXRyZWUtbm9kZSAjbXlOb2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbZGF0YV09XCJub2RlXCI+XG4gICAgICogICAgICAgICA8bmctdGVtcGxhdGUgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub2RlVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBkYXRhLCBwYXJlbnROb2RlOiBteU5vZGUgfVwiPlxuICAgICAqICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgPCEtLSBub2RlIHRlbXBsYXRlIGlzIGRlZmluZWQgdW5kZXIgdHJlZSB0byBhY2Nlc3MgcmVsYXRlZCBzZXJ2aWNlcyAtLT5cbiAgICAgKiAgICAgPG5nLXRlbXBsYXRlICNub2RlVGVtcGxhdGUgbGV0LWRhdGEgbGV0LW5vZGU9XCJwYXJlbnROb2RlXCI+XG4gICAgICogICAgICAgICA8YSBbaWd4VHJlZU5vZGVMaW5rXT1cIm5vZGVcIj57eyBkYXRhLmxhYmVsIH19PC9hPlxuICAgICAqICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUcmVlTm9kZUxpbmsnKVxuICAgIHB1YmxpYyBzZXQgcGFyZW50Tm9kZSh2YWw6IGFueSkge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnROb2RlID0gdmFsO1xuICAgICAgICAgICAgKHRoaXMuX3BhcmVudE5vZGUgYXMgYW55KS5hZGRMaW5rQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHBhcmVudE5vZGUoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLyoqIEEgcG9pbnRlciB0byB0aGUgcGFyZW50IG5vZGUgKi9cbiAgICBwcml2YXRlIGdldCB0YXJnZXQoKTogSWd4VHJlZU5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUgfHwgdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3BhcmVudE5vZGU6IElneFRyZWVOb2RlPGFueT4gPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVClcbiAgICBwcml2YXRlIG5vZGU6IElneFRyZWVOb2RlPGFueT4sXG4gICAgICAgIHByaXZhdGUgbmF2U2VydmljZTogSWd4VHJlZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXG4gICAgcHVibGljIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlID09PSB0aGlzLnRhcmdldCA/ICh0aGlzLnRhcmdldD8uZGlzYWJsZWQgPyAtMSA6IDApIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBDbGVhciB0aGUgbm9kZSdzIGZvY3VzZWQgc3RhdGVcbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgICBwdWJsaWMgaGFuZGxlQmx1cigpIHtcbiAgICAgICAgdGhpcy50YXJnZXQuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBTZXQgdGhlIG5vZGUgYXMgZm9jdXNlZFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgICBwdWJsaWMgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGUgIT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlID0gdGhpcy50YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaW5rQ2hpbGQodGhpcyk7XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBUaGUgdHJlZSBub2RlIGNvbXBvbmVudCByZXByZXNlbnRzIGEgY2hpbGQgbm9kZSBvZiB0aGUgdHJlZSBjb21wb25lbnQgb3IgYW5vdGhlciB0cmVlIG5vZGUuXG4gKiBVc2FnZTpcbiAqXG4gKiBgYGBodG1sXG4gKiAgPGlneC10cmVlPlxuICogIC4uLlxuICogICAgPGlneC10cmVlLW5vZGUgW2RhdGFdPVwiZGF0YVwiIFtzZWxlY3RlZF09XCJzZXJ2aWNlLmlzTm9kZVNlbGVjdGVkKGRhdGEuS2V5KVwiIFtleHBhbmRlZF09XCJzZXJ2aWNlLmlzTm9kZUV4cGFuZGVkKGRhdGEuS2V5KVwiPlxuICogICAgICB7eyBkYXRhLkZpcnN0TmFtZSB9fSB7eyBkYXRhLkxhc3ROYW1lIH19XG4gKiAgICA8L2lneC10cmVlLW5vZGU+XG4gKiAgLi4uXG4gKiAgPC9pZ3gtdHJlZT5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlLW5vZGUnLFxuICAgIHRlbXBsYXRlVXJsOiAndHJlZS1ub2RlLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVCwgdXNlRXhpc3Rpbmc6IElneFRyZWVOb2RlQ29tcG9uZW50IH1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVOb2RlQ29tcG9uZW50PFQ+IGV4dGVuZHMgVG9nZ2xlQW5pbWF0aW9uUGxheWVyIGltcGxlbWVudHMgSWd4VHJlZU5vZGU8VD4sIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBlbnRyeSB0aGF0IHRoZSBub2RlIGlzIHZpc3VhbGl6aW5nLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXF1aXJlZCBmb3Igc2VhcmNoaW5nIHRocm91Z2ggbm9kZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgICA8aWd4LXRyZWUtbm9kZSBbZGF0YV09XCJkYXRhXCI+XG4gICAgICogICAgICB7eyBkYXRhLkZpcnN0TmFtZSB9fSB7eyBkYXRhLkxhc3ROYW1lIH19XG4gICAgICogICAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkYXRhOiBUO1xuXG4gICAgLyoqXG4gICAgICogVG8gYmUgdXNlZCBmb3IgbG9hZC1vbi1kZW1hbmQgc2NlbmFyaW9zIGluIG9yZGVyIHRvIHNwZWNpZnkgd2hldGhlciB0aGUgbm9kZSBpcyBsb2FkaW5nIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIExvYWRpbmcgbm9kZXMgZG8gbm90IHJlbmRlciBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBsb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvLyBUTyBETzogcmV0dXJuIGRpZmZlcmVudCB0YWIgaW5kZXggZGVwZW5kaW5nIG9uIGFuY2hvciBjaGlsZFxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBzZXQgdGFiSW5kZXgodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdGFiSW5kZXggPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90YWJJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0xpbmtDaGlsZHJlbiA/IC0xIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNMaW5rQ2hpbGRyZW4gPyAtMSA6IHRoaXMuX3RhYkluZGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgYW5pbWF0aW9uU2V0dGluZ3MoKTogVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3Mge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmFuaW1hdGlvblNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgcmVzb3VyY2Ugc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlcyBFTiByZXNvdXJjZXMgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgcmVzb3VyY2VTdHJpbmdzKHZhbHVlOiBJVHJlZVJlc291cmNlU3RyaW5ncykge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZVN0cmluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXNvdXJjZVN0cmluZ3MsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhY2Nlc3NvciB0aGF0IHJldHVybnMgdGhlIHJlc291cmNlIHN0cmluZ3MuXG4gICAgICovXG4gICAgcHVibGljIGdldCByZXNvdXJjZVN0cmluZ3MoKTogSVRyZWVSZXNvdXJjZVN0cmluZ3Mge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc291cmNlU3RyaW5ncykge1xuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VTdHJpbmdzID0gQ3VycmVudFJlc291cmNlU3RyaW5ncy5UcmVlUmVzU3RyaW5ncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VTdHJpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IGJvb2xlYW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgYWN0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLmFjdGl2ZU5vZGUgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy50cmVlLmFjdGl2ZU5vZGVCaW5kaW5nQ2hhbmdlLmVtaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5hY3RpdmVOb2RlID09PSB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgbm9kZSdzIGBzZWxlY3RlZGAgcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgICA8aWd4LXRyZWUtbm9kZSAqbmdGb3I9XCJsZXQgbm9kZSBvZiBkYXRhXCIgW2RhdGFdPVwibm9kZVwiIFsoc2VsZWN0ZWQpXT1cIm5vZGUuc2VsZWN0ZWRcIj5cbiAgICAgKiAgICAgIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIG5vZGUuc2VsZWN0ZWRDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoZTogYm9vbGVhbikgPT4gY29uc29sZS5sb2coXCJOb2RlIHNlbGVjdGlvbiBjaGFuZ2VkIHRvIFwiLCBlKSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIG5vZGUncyBgZXhwYW5kZWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFtkYXRhXT1cIm5vZGVcIiBbKGV4cGFuZGVkKV09XCJub2RlLmV4cGFuZGVkXCI+XG4gICAgICogICAgICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBub2RlLmV4cGFuZGVkQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGU6IGJvb2xlYW4pID0+IGNvbnNvbGUubG9nKFwiTm9kZSBleHBhbnNpb24gc3RhdGUgY2hhbmdlZCB0byBcIiwgZSkpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBmb2N1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZvY3VzZWQgJiZcbiAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgbm9kZSBpbmN1ZGluZyBpdHNlbGZcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBjb25zdCBwYXRoOiBJZ3hUcmVlTm9kZTxhbnk+W10gPSBub2RlLnBhdGg7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYXRoKCk6IElneFRyZWVOb2RlPGFueT5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU/LnBhdGggPyBbLi4udGhpcy5wYXJlbnROb2RlLnBhdGgsIHRoaXNdIDogW3RoaXNdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGJpbmQgdG8gZGlzYWJsZWQgc3RhdGUgd2hlbiBub2RlIGlzIGRyYWdnZWRcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IGJvb2xlYW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRyZWUtbm9kZS0tZGlzYWJsZWQnKVxuICAgIHB1YmxpYyBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyZWUuZGlzYWJsZWRDaGFuZ2UuZW1pdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRyZWUtbm9kZScpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC10cmVlLW5vZGUnO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyBnZXQgcm9sZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTGlua0NoaWxkcmVuID8gJ25vbmUnIDogJ3RyZWVpdGVtJztcbiAgICB9O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hUcmVlTm9kZUxpbmtEaXJlY3RpdmUsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICAgIHB1YmxpYyBsaW5rQ2hpbGRyZW46IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSUdYX1RSRUVfTk9ERV9DT01QT05FTlQsIHsgcmVhZDogSUdYX1RSRUVfTk9ERV9DT01QT05FTlQgfSlcbiAgICBwdWJsaWMgX2NoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4VHJlZU5vZGU8YW55Pj47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElHWF9UUkVFX05PREVfQ09NUE9ORU5ULCB7IHJlYWQ6IElHWF9UUkVFX05PREVfQ09NUE9ORU5ULCBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIHB1YmxpYyBhbGxDaGlsZHJlbjogUXVlcnlMaXN0PElneFRyZWVOb2RlPGFueT4+O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZSAoaWYgYW55KVxuICAgICAqXG4gICAgICogQHJlbWFya1xuICAgICAqIFJldHVybnMgYG51bGxgIGlmIG5vZGUgZG9lcyBub3QgaGF2ZSBjaGlsZHJlblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgbm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogY29uc3QgY2hpbGRyZW46IElneFRyZWVOb2RlPGFueT5bXSA9IG5vZGUuY2hpbGRyZW47XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBjaGlsZHJlbigpOiBJZ3hUcmVlTm9kZTxhbnk+W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4/Lmxlbmd0aCA/IHRoaXMuX2NoaWxkcmVuLnRvQXJyYXkoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogd2lsbCBiZSB1c2VkIGluIERyYWcgYW5kIERyb3AgaW1wbGVtZW50YXRpb25cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAVmlld0NoaWxkKCdnaG9zdFRlbXBsYXRlJywgeyByZWFkOiBFbGVtZW50UmVmIH0pXG4gICAgcHVibGljIGhlYWRlcjogRWxlbWVudFJlZjtcblxuICAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHRJbmRpY2F0b3InLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwcml2YXRlIF9kZWZhdWx0RXhwYW5kSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAVmlld0NoaWxkKCdjaGlsZHJlbkNvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICAgIHByaXZhdGUgY2hpbGRyZW5Db250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICBwcml2YXRlIGdldCBoYXNMaW5rQ2hpbGRyZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtDaGlsZHJlbj8ubGVuZ3RoID4gMCB8fCB0aGlzLnJlZ2lzdGVyZWRDaGlsZHJlbj8ubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IGlzQ29tcGFjdCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZT8uZGlzcGxheURlbnNpdHkgPT09IERpc3BsYXlEZW5zaXR5LmNvbXBhY3Q7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBpc0Nvc3koKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU/LmRpc3BsYXlEZW5zaXR5ID09PSBEaXNwbGF5RGVuc2l0eS5jb3N5O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBpc0ZvY3VzZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgcmVnaXN0ZXJlZENoaWxkcmVuOiBJZ3hUcmVlTm9kZUxpbmtEaXJlY3RpdmVbXSA9IFtdO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHJpdmF0ZSBfcmVzb3VyY2VTdHJpbmdzID0gQ3VycmVudFJlc291cmNlU3RyaW5ncy5UcmVlUmVzU3RyaW5ncztcblxuICAgIHByaXZhdGUgX3RhYkluZGV4ID0gbnVsbDtcbiAgICBwcml2YXRlIF9kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX1RSRUVfQ09NUE9ORU5UKSBwdWJsaWMgdHJlZTogSWd4VHJlZSxcbiAgICAgICAgcHJvdGVjdGVkIHNlbGVjdGlvblNlcnZpY2U6IElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgdHJlZVNlcnZpY2U6IElneFRyZWVTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgbmF2U2VydmljZTogSWd4VHJlZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIGJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsXG4gICAgICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIEBJbmplY3QoSUdYX1RSRUVfTk9ERV9DT01QT05FTlQpIHB1YmxpYyBwYXJlbnROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGJ1aWxkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBzaG93U2VsZWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlbGVjdGlvbiAhPT0gSWd4VHJlZVNlbGVjdGlvblR5cGUuTm9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaW5kZXRlcm1pbmF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc05vZGVJbmRldGVybWluYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBUaGUgZGVwdGggb2YgdGhlIG5vZGUsIHJlbGF0aXZlIHRvIHRoZSByb290XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPGlneC10cmVlLW5vZGUgI25vZGU+XG4gICAgICogICAgICBNeSBsZXZlbCBpcyB7eyBub2RlLmxldmVsIH19XG4gICAgICogIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMTJdKVswXTtcbiAgICAgKiBjb25zdCBsZXZlbDogbnVtYmVyID0gbm9kZS5sZXZlbDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxldmVsKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUgPyB0aGlzLnBhcmVudE5vZGUubGV2ZWwgKyAxIDogMDtcbiAgICB9XG5cbiAgICAvKiogR2V0L3NldCB3aGV0aGVyIHRoZSBub2RlIGlzIHNlbGVjdGVkLiBTdXBwb3JzdCB0d28td2F5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFsoc2VsZWN0ZWQpXT1cIm5vZGUuc2VsZWN0ZWRcIj5cbiAgICAgKiAgICAgIHt7IG5vZGUubGFiZWwgfX1cbiAgICAgKiAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgbm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogY29uc3Qgc2VsZWN0ZWQgPSBub2RlLnNlbGVjdGVkO1xuICAgICAqIG5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc05vZGVTZWxlY3RlZCh0aGlzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNlbGVjdGVkKHZhbDogYm9vbGVhbikge1xuICAgICAgICBpZiAoISh0aGlzLnRyZWU/Lm5vZGVzICYmIHRoaXMudHJlZS5ub2Rlcy5maW5kKChlKSA9PiBlID09PSB0aGlzKSkgJiYgdmFsKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUuZm9yY2VTZWxlY3QucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsICYmICF0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNOb2RlU2VsZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3ROb2Rlc1dpdGhOb0V2ZW50KFt0aGlzXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWwgJiYgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzTm9kZVNlbGVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3ROb2Rlc1dpdGhOb0V2ZW50KFt0aGlzXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogR2V0L3NldCB3aGV0aGVyIHRoZSBub2RlIGlzIGV4cGFuZGVkXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFtleHBhbmRlZF09XCJub2RlLm5hbWUgPT09IHRoaXMuZXhwYW5kZWROb2RlXCI+XG4gICAgICogICAgICB7eyBub2RlLmxhYmVsIH19XG4gICAgICogIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIGNvbnN0IGV4cGFuZGVkID0gbm9kZS5leHBhbmRlZDtcbiAgICAgKiBub2RlLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVTZXJ2aWNlLmlzRXhwYW5kZWQodGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBleHBhbmRlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy50cmVlU2VydmljZS5leHBhbmQodGhpcywgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmVlU2VydmljZS5jb2xsYXBzZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgZXhwYW5kSW5kaWNhdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWU/LmV4cGFuZEluZGljYXRvciA/IHRoaXMudHJlZS5leHBhbmRJbmRpY2F0b3IgOiB0aGlzLl9kZWZhdWx0RXhwYW5kSW5kaWNhdG9yVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hdGl2ZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIG5vZGUuIENvdWxkIGJlIG51bGwgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0IHRoZSBuYXRpdmVFbGVtZW50IG9mIHRoZSBzZWNvbmQgbm9kZVxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlID0gdGhpcy50cmVlLm5vZGVzLmZpcnN0KCk7XG4gICAgICogY29uc3Qgbm9kZUVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gbm9kZS5uYXRpdmVFbGVtZW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5vcGVuQW5pbWF0aW9uRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5ub2RlRXhwYW5kZWQuZW1pdCh7IG93bmVyOiB0aGlzLnRyZWUsIG5vZGU6IHRoaXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmVlLm5vZGVDb2xsYXBzZWQuZW1pdCh7IG93bmVyOiB0aGlzLnRyZWUsIG5vZGU6IHRoaXMgfSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVTZXJ2aWNlLmNvbGxhcHNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogU2V0cyB0aGUgZm9jdXMgdG8gdGhlIG5vZGUncyA8YT4gY2hpbGQsIGlmIHByZXNlbnRcbiAgICAgKiBTZXRzIHRoZSBub2RlIGFzIHRoZSB0cmVlIHNlcnZpY2UncyBmb2N1c2VkTm9kZVxuICAgICAqIE1hcmtzIHRoZSBub2RlIGFzIHRoZSBjdXJyZW50IGFjdGl2ZSBlbGVtZW50XG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZUZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGUgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5saW5rQ2hpbGRyZW4/Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5saW5rQ2hpbGRyZW4uZmlyc3QubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuWzBdLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBDbGVhciB0aGUgbm9kZSdzIGZvY3VzZWQgc3RhdHVzXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyRm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25TZWxlY3RvckNsaWNrKGV2ZW50KSB7XG4gICAgICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyB0aGlzLm5hdlNlcnZpY2UuaGFuZGxlRm9jdXNlZEFuZEFjdGl2ZU5vZGUodGhpcyk7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdE11bHRpcGxlTm9kZXModGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3ROb2RlKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3ROb2RlKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIG5vZGUgZXhwYW5zaW9uIHN0YXRlLCB0cmlnZ2VyaW5nIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgICAgIDxpZ3gtdHJlZS1ub2RlICNub2RlPk15IE5vZGU8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiA8YnV0dG9uIGlneEJ1dHRvbiAoY2xpY2spPVwibm9kZS50b2dnbGUoKVwiPlRvZ2dsZSBOb2RlPC9idXR0b24+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlOb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBteU5vZGUudG9nZ2xlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgaW5kaWNhdG9yQ2xpY2soKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS5zZXRGb2N1c2VkQW5kQWN0aXZlTm9kZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2Uuc2V0Rm9jdXNlZEFuZEFjdGl2ZU5vZGUodGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZW5zdXJlU3RhdGVPbk5vZGVEZWxldGUodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgbm9kZSwgdHJpZ2dlcmluZyBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgICA8aWd4LXRyZWUtbm9kZSAjbm9kZT5NeSBOb2RlPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogPGJ1dHRvbiBpZ3hCdXR0b24gKGNsaWNrKT1cIm5vZGUuZXhwYW5kKClcIj5FeHBhbmQgTm9kZTwvYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG15Tm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogbXlOb2RlLmV4cGFuZCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmQoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3M6IElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMudHJlZSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmVlLm5vZGVFeHBhbmRpbmcuZW1pdChhcmdzKTtcbiAgICAgICAgaWYgKCFhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy50cmVlU2VydmljZS5leHBhbmQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLnBsYXlPcGVuQW5pbWF0aW9uKFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5Db250YWluZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgdGhlIG5vZGUsIHRyaWdnZXJpbmcgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICAgPGlneC10cmVlLW5vZGUgI25vZGU+TXkgTm9kZTwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIDxidXR0b24gaWd4QnV0dG9uIChjbGljayk9XCJub2RlLmNvbGxhcHNlKClcIj5Db2xsYXBzZSBOb2RlPC9idXR0b24+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlOb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBteU5vZGUuY29sbGFwc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sbGFwc2UoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3M6IElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMudHJlZSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmVlLm5vZGVDb2xsYXBzaW5nLmVtaXQoYXJncyk7XG4gICAgICAgIGlmICghYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVNlcnZpY2UuY29sbGFwc2luZyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGxheUNsb3NlQW5pbWF0aW9uKFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5Db250YWluZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgYWRkTGlua0NoaWxkKGxpbms6IElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZSkge1xuICAgICAgICB0aGlzLl90YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDaGlsZHJlbi5wdXNoKGxpbmspO1xuICAgIH07XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgcmVtb3ZlTGlua0NoaWxkKGxpbms6IElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuLmluZGV4T2YobGluayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=