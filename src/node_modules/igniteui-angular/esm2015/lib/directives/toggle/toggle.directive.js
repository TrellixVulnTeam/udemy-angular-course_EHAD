import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, Optional, Output, Inject } from '@angular/core';
import { IgxNavigationService } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { AbsoluteScrollStrategy, ConnectedPositioningStrategy } from '../../services/public_api';
import { filter, first, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
export class IgxToggleDirective {
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onAppended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.onAppended = new EventEmitter();
        this._collapsed = true;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        this.overlayClosed = (ev) => {
            this._collapsed = true;
            this.cdr.detectChanges();
            this.unsubscribe();
            this.overlayService.detach(this.overlayId);
            const closedEventArgs = { owner: this, id: this._overlayId, event: ev.event };
            delete this._overlayId;
            this.onClosed.emit(closedEventArgs);
        };
    }
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        var _a, _b, _c, _d;
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const openAnimationStarted = (_b = (_a = info === null || info === void 0 ? void 0 : info.openAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted()) !== null && _b !== void 0 ? _b : false;
        const closeAnimationStarted = (_d = (_c = info === null || info === void 0 ? void 0 : info.closeAnimationPlayer) === null || _c === void 0 ? void 0 : _c.hasStarted()) !== null && _d !== void 0 ? _d : false;
        if (openAnimationStarted || !(this._collapsed || closeAnimationStarted)) {
            return;
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        if (!info) {
            this.unsubscribe();
            this.subscribe();
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        const openEventArgs = { cancel: false, owner: this, id: this._overlayId };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this.unsubscribe();
            this.overlayService.detach(this._overlayId);
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close() {
        var _a;
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const closeAnimationStarted = ((_a = info === null || info === void 0 ? void 0 : info.closeAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted()) || false;
        if (this._collapsed || closeAnimationStarted) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is running close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        var _a;
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? (_a = info.closeAnimationPlayer) === null || _a === void 0 ? void 0 : _a.hasStarted() : false;
    }
    /**
     * Returns the id of the overlay the content is rendered in.
     * ```typescript
     * this.myToggle.overlayId;
     * ```
     */
    get overlayId() {
        return this._overlayId;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX, deltaY) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.detach(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    subscribe() {
        this._overlayAppendedSub = this.overlayService.onAppended
            .pipe(first(), takeUntil(this.destroy$))
            .subscribe(() => {
            const appendedEventArgs = { owner: this, id: this._overlayId };
            this.onAppended.emit(appendedEventArgs);
        });
        this._overlayOpenedSub = this.overlayService.onOpened
            .pipe(...this._overlaySubFilter)
            .subscribe(() => {
            const openedEventArgs = { owner: this, id: this._overlayId };
            this.onOpened.emit(openedEventArgs);
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const eventArgs = { cancel: false, event: e.event, owner: this, id: this._overlayId };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
}
IgxToggleDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'toggle',
                selector: '[igxToggle]'
            },] }
];
IgxToggleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxToggleDirective.propDecorators = {
    onOpened: [{ type: Output }],
    onOpening: [{ type: Output }],
    onClosed: [{ type: Output }],
    onClosing: [{ type: Output }],
    onAppended: [{ type: Output }],
    id: [{ type: Input }],
    hiddenClass: [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-toggle',] }]
};
export class IgxToggleActionDirective {
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const targetElement = this.element.nativeElement;
        this._overlayDefaults = {
            target: targetElement,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludeFromOutsideClick: [targetElement]
        };
    }
    /**
     * Updates provided overlay settings
     *
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
}
IgxToggleActionDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            },] }
];
IgxToggleActionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
IgxToggleActionDirective.propDecorators = {
    overlaySettings: [{ type: Input }],
    outlet: [{ type: Input, args: ['igxToggleOutlet',] }],
    target: [{ type: Input, args: ['igxToggleAction',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
export class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
}
IgxOverlayOutletDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            },] }
];
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: ElementRef }
];
/**
 * @hidden
 */
export class IgxToggleModule {
}
IgxToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL3RvZ2dsZS90b2dnbGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBQ0wsUUFBUSxFQUdSLFFBQVEsRUFDUixNQUFNLEVBQ04sTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBZSxNQUFNLHVCQUF1QixDQUFDO0FBQzFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ25FLE9BQU8sRUFDSCxzQkFBc0IsRUFDdEIsNEJBQTRCLEVBSS9CLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUQsT0FBTyxFQUFnQixPQUFPLEVBQTRCLE1BQU0sTUFBTSxDQUFDO0FBZ0J2RSxNQUFNLE9BQU8sa0JBQWtCO0lBc0ozQjs7T0FFRztJQUNILFlBQ1ksVUFBc0IsRUFDdEIsR0FBc0IsRUFDTyxjQUFpQyxFQUNsRCxpQkFBdUM7UUFIbkQsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQUNPLG1CQUFjLEdBQWQsY0FBYyxDQUFtQjtRQUNsRCxzQkFBaUIsR0FBakIsaUJBQWlCLENBQXNCO1FBNUovRDs7Ozs7Ozs7Ozs7Ozs7O1dBZUc7UUFFSSxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQXVCLENBQUM7UUFFMUQ7Ozs7Ozs7Ozs7Ozs7OztXQWVHO1FBRUksY0FBUyxHQUFHLElBQUksWUFBWSxFQUFp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QVU7WUFZTCxvQkFBb0IsdUJBa2JpQixRQUFROzs7OEJBdENqRCxLQUFLO3FCQVlMLEtBQUssU0FBQyxpQkFBaUI7cUJBTXZCLEtBQUssU0FBQyxpQkFBaUI7c0JBeUJ2QixZQUFZLFNBQUMsT0FBTzs7QUEyQ3pCOzs7Ozs7R0FNRztBQUtILE1BQU0sT0FBTyx5QkFBeUI7SUFDbEMsWUFBbUIsT0FBbUI7UUFBbkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtJQUFJLENBQUM7SUFFM0MsY0FBYztJQUNkLElBQVcsYUFBYTtRQUNwQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0lBQ3RDLENBQUM7OztZQVZKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixRQUFRLEVBQUUsb0JBQW9CO2FBQ2pDOzs7WUF4ZkcsVUFBVTs7QUFrZ0JkOztHQUVHO0FBTUgsTUFBTSxPQUFPLGVBQWU7OztZQUwzQixRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUUseUJBQXlCLENBQUM7Z0JBQ3ZGLE9BQU8sRUFBRSxDQUFDLGtCQUFrQixFQUFFLHdCQUF3QixFQUFFLHlCQUF5QixDQUFDO2dCQUNsRixTQUFTLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQzthQUNwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBJbmplY3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hOYXZpZ2F0aW9uU2VydmljZSwgSVRvZ2dsZVZpZXcgfSBmcm9tICcuLi8uLi9jb3JlL25hdmlnYXRpb24nO1xuaW1wb3J0IHsgSWd4T3ZlcmxheVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vdmVybGF5L292ZXJsYXknO1xuaW1wb3J0IHtcbiAgICBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5LFxuICAgIENvbm5lY3RlZFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gICAgSVBvc2l0aW9uU3RyYXRlZ3ksXG4gICAgT3ZlcmxheUV2ZW50QXJncyxcbiAgICBPdmVybGF5U2V0dGluZ3Ncbn0gZnJvbSAnLi4vLi4vc2VydmljZXMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBmaWx0ZXIsIGZpcnN0LCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFN1YmplY3QsIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vdmVybGF5L3V0aWxpdGllcyc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncywgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBUb2dnbGVWaWV3RXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBJZCBvZiB0aGUgdG9nZ2xlIHZpZXcgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIGV2ZW50PzogRXZlbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9nZ2xlVmlld0NhbmNlbGFibGVFdmVudEFyZ3MgZXh0ZW5kcyBUb2dnbGVWaWV3RXZlbnRBcmdzLCBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICd0b2dnbGUnLFxuICAgIHNlbGVjdG9yOiAnW2lneFRvZ2dsZV0nXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIElUb2dnbGVWaWV3LCBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmVkKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJUb2dnbGUgb3BlbmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuZWQpPSdvblRvZ2dsZU9wZW5lZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25PcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRvZ2dsZVZpZXdFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmluZyhldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBvcGVuaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuaW5nKT0nb25Ub2dnbGVPcGVuaW5nKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbk9wZW5pbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFRvZ2dsZVZpZXdDYW5jZWxhYmxlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlQ2xvc2VkKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIGNsb3NlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uQ2xvc2VkKT0nb25Ub2dnbGVDbG9zZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVWaWV3RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NpbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2luZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgaWd4VG9nZ2xlXG4gICAgICogIChvbkNsb3NpbmcpPSdvblRvZ2dsZUNsb3NpbmcoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2xvc2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0NhbmNlbGFibGVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIG92ZXJsYXkgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQXBwZW5kZWQoKSB7XG4gICAgICogIGFsZXJ0KFwiQ29udGVudCBhcHBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uQXBwZW5kZWQpPSdvblRvZ2dsZUFwcGVuZGVkKCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkFwcGVuZGVkID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVWaWV3RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXIgd2hpY2ggaXMgcmVnaXN0ZXJlZCBpbnRvIGBJZ3hOYXZpZ2F0aW9uU2VydmljZWBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbXlUb2dnbGVJZCA9IHRoaXMudG9nZ2xlLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBlbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10b2dnbGUtLWhpZGRlbicpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtaGlkZGVuJylcbiAgICBwdWJsaWMgZ2V0IGhpZGRlbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRvZ2dsZScpXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9vdmVybGF5SWQ6IHN0cmluZztcblxuICAgIHByaXZhdGUgX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheVN1YkZpbHRlcjogW01vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxPdmVybGF5RXZlbnRBcmdzPiwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPE92ZXJsYXlFdmVudEFyZ3M+XSA9IFtcbiAgICAgICAgZmlsdGVyKHggPT4geC5pZCA9PT0gdGhpcy5fb3ZlcmxheUlkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgXTtcbiAgICBwcml2YXRlIF9vdmVybGF5T3BlbmVkU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NpbmdTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9vdmVybGF5Q2xvc2VkU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUFwcGVuZGVkU3ViOiBTdWJzY3JpcHRpb247XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KElneE92ZXJsYXlTZXJ2aWNlKSBwcm90ZWN0ZWQgb3ZlcmxheVNlcnZpY2U6IElneE92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5vcGVuKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9wZW4ob3ZlcmxheVNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzKSB7XG4gICAgICAgIC8vICBpZiB0aGVyZSBpcyBvcGVuIGFuaW1hdGlvbiBkbyBub3RoaW5nXG4gICAgICAgIC8vICBpZiB0b2dnbGUgaXMgbm90IGNvbGxhcHNlZCBhbmQgdGhlcmUgaXMgbm8gY2xvc2UgYW5pbWF0aW9uIGRvIG5vdGhpbmdcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMub3ZlcmxheVNlcnZpY2UuZ2V0T3ZlcmxheUJ5SWQodGhpcy5fb3ZlcmxheUlkKTtcbiAgICAgICAgY29uc3Qgb3BlbkFuaW1hdGlvblN0YXJ0ZWQgPSBpbmZvPy5vcGVuQW5pbWF0aW9uUGxheWVyPy5oYXNTdGFydGVkKCkgPz8gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb3NlQW5pbWF0aW9uU3RhcnRlZCA9IGluZm8/LmNsb3NlQW5pbWF0aW9uUGxheWVyPy5oYXNTdGFydGVkKCkgPz8gZmFsc2U7XG4gICAgICAgIGlmIChvcGVuQW5pbWF0aW9uU3RhcnRlZCB8fCAhKHRoaXMuX2NvbGxhcHNlZCB8fCBjbG9zZUFuaW1hdGlvblN0YXJ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlJZCA9IHRoaXMub3ZlcmxheVNlcnZpY2UuYXR0YWNoKHRoaXMuZWxlbWVudFJlZiwgb3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wZW5FdmVudEFyZ3M6IFRvZ2dsZVZpZXdDYW5jZWxhYmxlRXZlbnRBcmdzID0geyBjYW5jZWw6IGZhbHNlLCBvd25lcjogdGhpcywgaWQ6IHRoaXMuX292ZXJsYXlJZCB9O1xuICAgICAgICB0aGlzLm9uT3BlbmluZy5lbWl0KG9wZW5FdmVudEFyZ3MpO1xuICAgICAgICBpZiAob3BlbkV2ZW50QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuZGV0YWNoKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2Uuc2hvdyh0aGlzLl9vdmVybGF5SWQsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpIHtcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBjb2xsYXBzZWQgZG8gbm90aGluZ1xuICAgICAgICAvLyAgaWYgdGhlcmUgaXMgY2xvc2UgYW5pbWF0aW9uIGRvIG5vdGhpbmcsIHRvZ2dsZSB3aWxsIGNsb3NlIGFueXdheVxuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBjbG9zZUFuaW1hdGlvblN0YXJ0ZWQgPSBpbmZvPy5jbG9zZUFuaW1hdGlvblBsYXllcj8uaGFzU3RhcnRlZCgpIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fY29sbGFwc2VkIHx8IGNsb3NlQW5pbWF0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5oaWRlKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgb3IgY2xvc2VzIHRoZSB0b2dnbGUsIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUob3ZlcmxheVNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzKSB7XG4gICAgICAgIC8vICBpZiB0b2dnbGUgaXMgY29sbGFwc2VkIGNhbGwgb3BlblxuICAgICAgICAvLyAgaWYgdGhlcmUgaXMgcnVubmluZyBjbG9zZSBhbmltYXRpb24gY2FsbCBvcGVuXG4gICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCB8fCB0aGlzLmlzQ2xvc2luZykge1xuICAgICAgICAgICAgdGhpcy5vcGVuKG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IGlzQ2xvc2luZygpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMub3ZlcmxheVNlcnZpY2UuZ2V0T3ZlcmxheUJ5SWQodGhpcy5fb3ZlcmxheUlkKTtcbiAgICAgICAgcmV0dXJuIGluZm8gPyBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyPy5oYXNTdGFydGVkKCkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgb3ZlcmxheSB0aGUgY29udGVudCBpcyByZW5kZXJlZCBpbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5vdmVybGF5SWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBvdmVybGF5SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5SWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwb3NpdGlvbnMgdGhlIHRvZ2dsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5yZXBvc2l0aW9uKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHJlcG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UucmVwb3NpdGlvbih0aGlzLl9vdmVybGF5SWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9mZnNldHMgdGhlIGNvbnRlbnQgYWxvbmcgdGhlIGNvcnJlc3BvbmRpbmcgYXhpcyBieSB0aGUgcHJvdmlkZWQgYW1vdW50XG4gICAgICovXG4gICAgcHVibGljIHNldE9mZnNldChkZWx0YVg6IG51bWJlciwgZGVsdGFZOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5zZXRPZmZzZXQodGhpcy5fb3ZlcmxheUlkLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hZGQodGhpcy5pZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZSAmJiB0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29sbGFwc2VkICYmIHRoaXMuX292ZXJsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5kZXRhY2godGhpcy5fb3ZlcmxheUlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb3ZlcmxheUNsb3NlZCA9IChldikgPT4ge1xuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5kZXRhY2godGhpcy5vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBjbG9zZWRFdmVudEFyZ3M6IFRvZ2dsZVZpZXdFdmVudEFyZ3MgPSB7IG93bmVyOiB0aGlzLCBpZDogdGhpcy5fb3ZlcmxheUlkLCBldmVudDogZXYuZXZlbnQgfTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX292ZXJsYXlJZDtcbiAgICAgICAgdGhpcy5vbkNsb3NlZC5lbWl0KGNsb3NlZEV2ZW50QXJncyk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5QXBwZW5kZWRTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLm9uQXBwZW5kZWRcbiAgICAgICAgICAgIC5waXBlKGZpcnN0KCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcGVuZGVkRXZlbnRBcmdzOiBUb2dnbGVWaWV3RXZlbnRBcmdzID0geyBvd25lcjogdGhpcywgaWQ6IHRoaXMuX292ZXJsYXlJZCB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25BcHBlbmRlZC5lbWl0KGFwcGVuZGVkRXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX292ZXJsYXlPcGVuZWRTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLm9uT3BlbmVkXG4gICAgICAgICAgICAucGlwZSguLi50aGlzLl9vdmVybGF5U3ViRmlsdGVyKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlbmVkRXZlbnRBcmdzOiBUb2dnbGVWaWV3RXZlbnRBcmdzID0geyBvd25lcjogdGhpcywgaWQ6IHRoaXMuX292ZXJsYXlJZCB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25PcGVuZWQuZW1pdChvcGVuZWRFdmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheUNsb3NpbmdTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlXG4gICAgICAgICAgICAub25DbG9zaW5nXG4gICAgICAgICAgICAucGlwZSguLi50aGlzLl9vdmVybGF5U3ViRmlsdGVyKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZTogT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEFyZ3M6IFRvZ2dsZVZpZXdDYW5jZWxhYmxlRXZlbnRBcmdzID0geyBjYW5jZWw6IGZhbHNlLCBldmVudDogZS5ldmVudCwgb3duZXI6IHRoaXMsIGlkOiB0aGlzLl9vdmVybGF5SWQgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2luZy5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgZS5jYW5jZWwgPSBldmVudEFyZ3MuY2FuY2VsO1xuXG4gICAgICAgICAgICAgICAgLy8gIGluIGNhc2UgZXZlbnQgaXMgbm90IGNhbmNlbGVkIHRoaXMgd2lsbCBjbG9zZSB0aGUgdG9nZ2xlIGFuZCB3ZSBuZWVkIHRvIHVuc3Vic2NyaWJlLlxuICAgICAgICAgICAgICAgIC8vICBPdGhlcndpc2UgaWYgZm9yIHNvbWUgcmVhc29uLCBlLmcuIGNsb3NlIG9uIG91dHNpZGUgY2xpY2ssIGNsb3NlKCkgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gIG9uQ2xvc2VkIHdhcyBmaXJlZCB3ZSB3aWxsIGVuZCB3aXRoIGNhbGxpbmcgb25DbG9zaW5nIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFlLmNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5Q2xvc2VkU3ViID0gdGhpcy5vdmVybGF5U2VydmljZS5vbkNsb3NlZFxuICAgICAgICAgICAgLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlcilcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vdmVybGF5Q2xvc2VkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlPcGVuZWRTdWIpO1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2VkU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5QXBwZW5kZWRTdWIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYXJTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiAhc3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAndG9nZ2xlLWFjdGlvbicsXG4gICAgc2VsZWN0b3I6ICdbaWd4VG9nZ2xlQWN0aW9uXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlQWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlIHNldHRpbmdzIHRoYXQgY29udHJvbCB0aGUgdG9nZ2xlIG92ZXJsYXkgcG9zaXRpb25pbmcsIGludGVyYWN0aW9uIGFuZCBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICogICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiBmYWxzZSxcbiAgICAgKiAgICAgIG1vZGFsOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICogLS0tXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbb3ZlcmxheVNldHRpbmdzXT1cInNldHRpbmdzXCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgb3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3M7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXJlIHRoZSB0b2dnbGUgZWxlbWVudCBvdmVybGF5IHNob3VsZCBiZSBhdHRhY2hlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGRpdiBpZ3hUb2dnbGVBY3Rpb24gW2lneFRvZ2dsZU91dGxldF09XCJvdXRsZXRcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBXaGVyZSBgb3V0bGV0YCBpbiBhbiBpbnN0YW5jZSBvZiBgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZWAgb3IgYW4gYEVsZW1lbnRSZWZgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUb2dnbGVPdXRsZXQnKVxuICAgIHB1YmxpYyBvdXRsZXQ6IElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUgfCBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4VG9nZ2xlQWN0aW9uJylcbiAgICBwdWJsaWMgc2V0IHRhcmdldCh0YXJnZXQ6IGFueSkge1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRhcmdldCgpOiBhbnkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3RhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmdldCh0aGlzLl90YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9vdmVybGF5RGVmYXVsdHM6IE92ZXJsYXlTZXR0aW5ncztcbiAgICBwcm90ZWN0ZWQgX3RhcmdldDogSVRvZ2dsZVZpZXcgfCBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIEBPcHRpb25hbCgpIHByaXZhdGUgbmF2aWdhdGlvblNlcnZpY2U6IElneE5hdmlnYXRpb25TZXJ2aWNlKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgcHVibGljIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLm91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzLm91dGxldCA9IHRoaXMub3V0bGV0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xvbmVkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vdmVybGF5RGVmYXVsdHMsIHRoaXMub3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5U2V0dGluZ3MoY2xvbmVkU2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnRhcmdldC50b2dnbGUoY2xvbmVkU2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRFbGVtZW50LFxuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneTogbmV3IENvbm5lY3RlZFBvc2l0aW9uaW5nU3RyYXRlZ3koKSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiBuZXcgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSgpLFxuICAgICAgICAgICAgY2xvc2VPbk91dHNpZGVDbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGV4Y2x1ZGVGcm9tT3V0c2lkZUNsaWNrOiBbdGFyZ2V0RWxlbWVudCBhcyBIVE1MRWxlbWVudF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBzZXR0aW5ncyB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyByZXR1cm5zIHVwZGF0ZWQgY29weSBvZiBwcm92aWRlZCBvdmVybGF5IHNldHRpbmdzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZU92ZXJsYXlTZXR0aW5ncyhzZXR0aW5nczogT3ZlcmxheVNldHRpbmdzKTogT3ZlcmxheVNldHRpbmdzIHtcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uU3RyYXRlZ3lDbG9uZTogSVBvc2l0aW9uU3RyYXRlZ3kgPSBzZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LmNsb25lKCk7XG4gICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kgPSBwb3NpdGlvblN0cmF0ZWd5Q2xvbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxufVxuXG4vKipcbiAqIE1hcmsgYW4gZWxlbWVudCBhcyBhbiBpZ3hPdmVybGF5IG91dGxldCBjb250YWluZXIuXG4gKiBEaXJlY3RpdmUgaW5zdGFuY2UgaXMgZXhwb3J0ZWQgYXMgYG92ZXJsYXktb3V0bGV0YCB0byBiZSBhc3NpZ25lZCB0byB0ZW1wbGF0ZXMgdmFyaWFibGVzOlxuICogYGBgaHRtbFxuICogPGRpdiBpZ3hPdmVybGF5T3V0bGV0ICNvdXRsZXQ9XCJvdmVybGF5LW91dGxldFwiPjwvZGl2PlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnb3ZlcmxheS1vdXRsZXQnLFxuICAgIHNlbGVjdG9yOiAnW2lneE92ZXJsYXlPdXRsZXRdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZikgeyB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4VG9nZ2xlRGlyZWN0aXZlLCBJZ3hUb2dnbGVBY3Rpb25EaXJlY3RpdmUsIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmVdLFxuICAgIGV4cG9ydHM6IFtJZ3hUb2dnbGVEaXJlY3RpdmUsIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSwgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbSWd4TmF2aWdhdGlvblNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZU1vZHVsZSB7IH1cbiJdfQ==