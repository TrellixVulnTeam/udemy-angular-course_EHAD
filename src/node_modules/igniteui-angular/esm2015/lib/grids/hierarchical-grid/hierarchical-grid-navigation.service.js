import { IgxGridNavigationService } from '../grid-navigation.service';
import { first } from 'rxjs/operators';
import { SUPPORTED_KEYS, NAVIGATION_KEYS } from '../../core/utils';
import { Injectable } from '@angular/core';
import { IgxChildGridRowComponent } from './child-grid-row.component';
export class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.crudService.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.chunkLoad.pipe(first()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     *
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const rowObj = this.grid.gridAPI.get_row_by_index(rowIndex);
        if (!rowObj) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(rowObj, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.chunkLoad.pipe(first()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     *
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     *
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     *
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(rowObj, isNext) {
        let rowElem = rowObj.nativeElement;
        if (rowObj instanceof IgxChildGridRowComponent) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: rowObj.rowData.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    /**
     * Gets closest element by its tag name.
     *
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode) {
            this.activeNode.row = null;
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev };
    }
}
IgxHierarchicalGridNavigationService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGllcmFyY2hpY2FsLWdyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2hpZXJhcmNoaWNhbC1ncmlkL2hpZXJhcmNoaWNhbC1ncmlkLW5hdmlnYXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUV0RSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdkMsT0FBTyxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBT3RFLE1BQU0sT0FBTyxvQ0FBcUMsU0FBUSx3QkFBd0I7SUFEbEY7O1FBSWMsdUJBQWtCLEdBQUcsS0FBSyxDQUFDO0lBcVl6QyxDQUFDO0lBbFlVLGFBQWEsQ0FBQyxLQUFvQjtRQUNyQyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvRixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFO1lBQ2xGLE9BQU87U0FDVjtRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLHVCQUF1QixDQUFDLENBQUM7UUFDbkYsSUFBSSxVQUFVLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDeEMsT0FBTztTQUNWO1FBRUQsSUFBSSxJQUFJLENBQUMsa0JBQWtCLElBQUksZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNyRCx3R0FBd0c7WUFDeEcsZ0ZBQWdGO1lBQ2hGLDZCQUE2QjtZQUM3QixLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDdkIsT0FBTztTQUNWO1FBQ0QsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRU0sY0FBYyxDQUFDLFFBQVEsRUFBRSxlQUFlLEVBQUUsS0FBeUIsSUFBSTtRQUMxRSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3hDLHVCQUF1QjtZQUN4QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQztZQUN6RCxNQUFNLE1BQU0sR0FBRyxRQUFRLElBQUksU0FBUyxDQUFDLFVBQVUsSUFBSSxRQUFRLElBQUksU0FBUyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDO1lBQzFHLE1BQU0sTUFBTSxHQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQztZQUMvQyxNQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQy9FLElBQUksTUFBTSxFQUFFO2dCQUNULElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDL0U7aUJBQU07Z0JBQ0gsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMUYsWUFBWSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDO2dCQUN2RSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO2dCQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO29CQUNyRSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUM1RSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDO2dCQUNwQyxDQUFDLENBQUMsQ0FBQzthQUNOO1lBQ0QsT0FBTztTQUNWO1FBRUQsTUFBTSxNQUFNLEdBQUcsUUFBUSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUN0RCxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztZQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7WUFDM0IsNEJBQTRCO1lBQzVCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZELElBQUksZ0JBQWdCLEtBQUssSUFBSSxFQUFFO2dCQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3JIO2lCQUFNO2dCQUNILElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUNuRDtZQUNELE9BQU87U0FDVjtRQUVELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDbEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDbkgsTUFBTSxTQUFTLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDNUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2IsQ0FBQyxDQUFDO1lBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQzthQUNqRDtZQUNELEtBQUssQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUMzRCxPQUFPO1NBQ1Y7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNsQixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDakQ7UUFDRCxLQUFLLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxlQUFlLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVNLDJCQUEyQixDQUFDLEtBQUssRUFBRSxrQkFBa0IsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFPO1FBQ3RFLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN4QyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pGLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDO1lBQzNFLE1BQU0sWUFBWSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsWUFBWSxDQUFDO1lBQ3JGLE9BQU8sWUFBWSxDQUFDO1NBQ3ZCO2FBQU07WUFDSCxPQUFPLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztTQUN2RTtJQUNMLENBQUM7SUFFTSxVQUFVLENBQUMsS0FBSztRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsS0FBSyxJQUFJLEVBQUU7WUFDbEQsSUFBSSxDQUFDLFVBQVUsR0FBRztnQkFDZCxHQUFHLEVBQUUsQ0FBQztnQkFDTixNQUFNLEVBQUUsQ0FBQzthQUNaLENBQUM7WUFFRixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUU7Z0JBQy9CLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztnQkFDL0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDL0IsQ0FBQyxDQUFDLENBQUM7U0FFTjthQUFNO1lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQjtJQUNMLENBQUM7SUFFUyxnQkFBZ0IsQ0FBQyxNQUFNO1FBQzdCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFDaEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4RSxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDN0QsSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQzVFLE9BQU8sU0FBUyxDQUFDO1NBQ3BCO2FBQU07WUFDSCxPQUFPLElBQUksQ0FBQztTQUNmO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLG9CQUFvQixDQUFDLFFBQWdCLEVBQUUsTUFBZ0IsRUFBRSxFQUFlO1FBQzlFLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUUsSUFBSSxZQUFZLEVBQUU7WUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQywyQkFBMkIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFO2dCQUNoRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNoRCxDQUFDLENBQUMsQ0FBQztTQUNOO2FBQU07WUFDSCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztTQUMvQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsRUFBZTtRQUN4RCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM1RCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsSUFBSSxFQUFFLEVBQUU7Z0JBQ0osRUFBRSxFQUFFLENBQUM7YUFDUjtZQUNELE9BQU87U0FDVjtRQUNELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzFELElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFO1lBQ3RCLDBFQUEwRTtZQUMxRSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO1lBQy9CLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1RyxjQUFjLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDaEUsY0FBYyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzlFLGNBQWMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7Z0JBQy9FLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7Z0JBQ2hDLElBQUksRUFBRSxFQUFFO29CQUNKLEVBQUUsRUFBRSxDQUFDO2lCQUNSO1lBQ0wsQ0FBQyxDQUFDLENBQUM7U0FDTjthQUFNO1lBQ0gsSUFBSSxFQUFFLEVBQUU7Z0JBQ0osRUFBRSxFQUFFLENBQUM7YUFDUjtTQUNKO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sWUFBWSxDQUFDLGNBQXNCLEVBQUUsZUFBdUIsRUFBRSxNQUFlLEVBQUUsZ0JBQXlCLEVBQzFGLEVBQXVCO1FBQzNDLE1BQU0sRUFBRSxHQUFHLE9BQU8sZ0JBQWdCLEtBQUssUUFBUSxDQUFDLENBQUM7WUFDaEQsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3pGLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUN2RCxNQUFNLFdBQVcsR0FBaUI7WUFDOUIsS0FBSyxFQUFFLEtBQUs7WUFDWixZQUFZLEVBQUUsRUFBRSxDQUFDLEdBQUc7U0FDdkIsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDbEUsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUMvRCxNQUFNLFNBQVMsR0FBSSxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDWiwyREFBMkQ7WUFDM0QsU0FBUyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN0RSxPQUFPO1NBQ1Y7UUFDRCxJQUFJLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN4Qyx3REFBd0Q7WUFDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7WUFDM0MsU0FBUyxDQUFDLFVBQVUsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBQyxDQUFDO1lBQ3RGLFNBQVMsQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7Z0JBQ2hFLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztnQkFDdEYsU0FBUyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDbkcsQ0FBQyxDQUFDLENBQUM7WUFDSCxPQUFPO1NBQ1Y7UUFFRCxNQUFNLFlBQVksR0FBSSxTQUFTLENBQUMsVUFBVSxDQUFDO1FBQzNDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixNQUFNLGdCQUFnQixHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUM7UUFDdEQsTUFBTSxXQUFXLEdBQUcsZUFBZSxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDO1FBQzdGLFlBQVksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUMsQ0FBQztRQUNuRSxTQUFTLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFBQyxhQUFhLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDO1FBQ2hDLFNBQVMsQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7WUFDaEUsU0FBUyxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxhQUFhLENBQUMsTUFBZSxFQUFFLFdBQVcsRUFBRSxFQUFHO1FBQ3JELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztRQUMvQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNsRixJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ2hCLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixNQUFNLGNBQWMsR0FBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7UUFDdkUsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDO1FBQ3JFLE1BQU0sZUFBZSxHQUFHLFdBQVcsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQztRQUN6RixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO1FBQy9CLE1BQU0sTUFBTSxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDcEIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztZQUNoQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDVCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pELENBQUMsQ0FBQztRQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN4RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sZUFBZSxDQUFDLE1BQXdELEVBQUUsTUFBZTtRQUMvRixJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDO1FBQ25DLElBQUksTUFBTSxZQUFZLHdCQUF3QixFQUFFO1lBQzVDLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ2xELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN4RixNQUFNLFdBQVcsR0FBaUI7Z0JBQzlCLEtBQUssRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUs7Z0JBQzNCLFlBQVksRUFBRSxLQUFLO2FBQ3RCLENBQUM7WUFDRixNQUFNLFNBQVMsR0FBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ2xFLE9BQU8sR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQztTQUMzQztRQUNELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pELE1BQU0sVUFBVSxHQUNoQixPQUFPLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDO1FBQ3BELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU07WUFDdEQsT0FBTyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUM7UUFDL0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO1FBQ3pELE1BQU0sVUFBVSxHQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFFbEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxTQUFTO1FBQy9DLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQztRQUN4QixPQUFPLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxDQUFDLEVBQUU7WUFDN0MsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLFNBQVMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDMUQsT0FBTyxNQUFNLENBQUM7YUFDakI7WUFDRCxNQUFNLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztTQUM5QjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTyxlQUFlO1FBQ25CLHVDQUF1QztRQUN2QyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO1NBQzlCO0lBQ0wsQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBYSxFQUFFLE1BQWU7UUFDdEQsTUFBTSxjQUFjLEdBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sZUFBZSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hELElBQUksZUFBZSxFQUFFO1lBQ2pCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7YUFBTTtZQUNILElBQUksdUJBQXVCLEdBQUcsS0FBSyxDQUFDO1lBQ3BDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDYixNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQkFDMUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUNwRjtZQUNELE9BQU8sdUJBQXVCLENBQUM7U0FDbEM7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLFVBQVUsQ0FBQyxJQUFJO1FBQ25CLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztRQUNwQixJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsQ0FBQztRQUNuRSxPQUFPLFFBQVEsQ0FBQyxNQUFNLEVBQUU7WUFDcEIsUUFBUSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7WUFDM0IsTUFBTSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLElBQUksUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEgsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsR0FBRyxHQUFHLGdCQUFnQixDQUFDLENBQUM7U0FDcEc7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssYUFBYSxDQUFDLElBQUk7UUFDdEIsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsTUFBTSxDQUFDO1FBQ3pFLE9BQU8sUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUNwQixRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztZQUMzQixNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pILE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQzdHO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxxQkFBcUIsQ0FBQyxJQUFJO1FBQzlCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDM0IsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNYLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1NBQy9CO1FBQ0QsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLHVCQUF1QixDQUFDLGNBQWMsQ0FBQztRQUNoRSxJQUFJLFlBQVksR0FBRyxRQUFRLENBQUMsdUJBQXVCLENBQUMsU0FBUyxFQUFFLENBQUMsWUFBWSxDQUFDO1FBQzdFLElBQUksYUFBYSxHQUFHLFlBQVksS0FBSyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLFlBQVksQ0FBQztRQUNsRyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsT0FBTyxhQUFhLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7WUFDOUMsSUFBSSxHQUFHLFFBQVEsQ0FBQztZQUNoQixRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztZQUMzQixTQUFTLEdBQUcsUUFBUSxDQUFDLHVCQUF1QixDQUFDLGNBQWMsQ0FBQztZQUM1RCxZQUFZLEdBQUcsUUFBUSxDQUFDLHVCQUF1QixDQUFDLFNBQVMsRUFBRSxDQUFDLFlBQVksQ0FBQztZQUN6RSxhQUFhLEdBQUcsWUFBWSxLQUFLLENBQUM7Z0JBQzlCLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLFlBQVksQ0FBQztTQUNyRztRQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssbUJBQW1CLENBQUMsSUFBSTtRQUM1QixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDWCxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUMvQjtRQUNELElBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxjQUFjLEtBQUssQ0FBQyxDQUFDO1FBQzFFLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixPQUFPLGFBQWEsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLElBQUksRUFBRTtZQUM5QyxJQUFJLEdBQUcsUUFBUSxDQUFDO1lBQ2hCLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQzNCLGFBQWEsR0FBRyxRQUFRLENBQUMsdUJBQXVCLENBQUMsY0FBYyxLQUFLLENBQUMsQ0FBQztTQUN6RTtRQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3BDLENBQUM7OztZQXhZSixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4SGllcmFyY2hpY2FsR3JpZENvbXBvbmVudCB9IGZyb20gJy4vaGllcmFyY2hpY2FsLWdyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU1VQUE9SVEVEX0tFWVMsIE5BVklHQVRJT05fS0VZUyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q2hpbGRHcmlkUm93Q29tcG9uZW50IH0gZnJvbSAnLi9jaGlsZC1ncmlkLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VEaXJlY3RpdmUgfSBmcm9tICcuLi9ncmlkL3B1YmxpY19hcGknO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVBhdGhTZWdtZW50IH0gZnJvbSAnLi9oaWVyYXJjaGljYWwtZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hSb3dEaXJlY3RpdmUgfSBmcm9tICcuLi9yb3cuZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneEhpZXJhcmNoaWNhbEdyaWROYXZpZ2F0aW9uU2VydmljZSBleHRlbmRzIElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB7XG4gICAgcHVibGljIGdyaWQ6IElneEhpZXJhcmNoaWNhbEdyaWRDb21wb25lbnQ7XG5cbiAgICBwcm90ZWN0ZWQgX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG5cblxuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSB8fCAhKFNVUFBPUlRFRF9LRVlTLmhhcyhrZXkpIHx8IChrZXkgPT09ICd0YWInICYmIHRoaXMuZ3JpZC5jcnVkU2VydmljZS5jZWxsKSkgJiZcbiAgICAgICAgICAgICF0aGlzLmdyaWQuY3J1ZFNlcnZpY2Uucm93RWRpdGluZ0Jsb2NrZWQgJiYgIXRoaXMuZ3JpZC5jcnVkU2VydmljZS5yb3dJbkVkaXRNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXRHcmlkID0gdGhpcy5nZXRDbG9zZXN0RWxlbUJ5VGFnKGV2ZW50LnRhcmdldCwgJ2lneC1oaWVyYXJjaGljYWwtZ3JpZCcpO1xuICAgICAgICBpZiAodGFyZ2V0R3JpZCAhPT0gdGhpcy5ncmlkLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiAmJiBOQVZJR0FUSU9OX0tFWVMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgZm9jdXMgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBvbmUgZ3JpZCB0byBhbm90aGVyLCBob3dldmVyIHRoZXJlIGlzIGEgcGVuZGluZyBzY3JvbGwgb3BlcmF0aW9uXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBhbiBhc3luYyBvcGVyYXRpb24sIGFueSBhZGRpdGlvbmFsIG5hdmlnYXRpb24ga2V5cyBzaG91bGQgYmUgaWdub3JlZFxuICAgICAgICAgICAgLy8gdW50aWxsIG9wZXJhdGlvbiBjb21wbGV0ZS5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5hdmlnYXRlSW5Cb2R5KHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiOiAoYXJnOiBhbnkpID0+IHZvaWQgPSBudWxsKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuZ3JpZC5kYXRhVmlld1tyb3dJbmRleF07XG4gICAgICAgIGlmIChyZWMgJiYgdGhpcy5ncmlkLmlzQ2hpbGRHcmlkUmVjb3JkKHJlYykpIHtcbiAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgY2hpbGQgZ3JpZFxuICAgICAgICAgICAgY29uc3QgdmlydFN0YXRlID0gdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnN0YXRlO1xuICAgICAgICAgICAgIGNvbnN0IGluVmlldyA9IHJvd0luZGV4ID49IHZpcnRTdGF0ZS5zdGFydEluZGV4ICYmIHJvd0luZGV4IDw9IHZpcnRTdGF0ZS5zdGFydEluZGV4ICsgdmlydFN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgICAgICBjb25zdCBpc05leHQgPSAgdGhpcy5hY3RpdmVOb2RlLnJvdyA8IHJvd0luZGV4O1xuICAgICAgICAgICAgIGNvbnN0IHRhcmdldExheW91dEluZGV4ID0gaXNOZXh0ID8gbnVsbCA6IHRoaXMuZ3JpZC5jaGlsZExheW91dEtleXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICBpZiAoaW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVRvQ2hpbGQocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNOZXh0LCB0YXJnZXRMYXlvdXRJbmRleCwgY2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc2Nyb2xsQW1vdW50ID0gdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbEZvckluZGV4KHJvd0luZGV4LCAhaXNOZXh0KTtcbiAgICAgICAgICAgICAgICBzY3JvbGxBbW91bnQgKz0gaXNOZXh0ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGwoKS5zY3JvbGxUb3AgPSBzY3JvbGxBbW91bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5jaHVua0xvYWQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlVG9DaGlsZChyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc05leHQsIHRhcmdldExheW91dEluZGV4LCBjYik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0xhc3QgPSByb3dJbmRleCA9PT0gdGhpcy5ncmlkLmRhdGFWaWV3Lmxlbmd0aDtcbiAgICAgICAgaWYgKChyb3dJbmRleCA9PT0gLTEgfHwgaXNMYXN0KSAmJlxuICAgICAgICAgICAgdGhpcy5ncmlkLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBlbmQgb2YgY2hpbGQgZ3JpZFxuICAgICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdJbmRleCA9IHRoaXMubmV4dFNpYmxpbmdJbmRleChpc0xhc3QpO1xuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQucGFyZW50Lm5hdmlnYXRpb24uX21vdmVUb0NoaWxkKHRoaXMuZ3JpZC5jaGlsZFJvdy5pbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc0xhc3QsIG5leHRTaWJsaW5nSW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVRvUGFyZW50KGlzTGFzdCwgdmlzaWJsZUNvbEluZGV4LCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmlkLnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgaXNOZXh0ID0gdGhpcy5hY3RpdmVOb2RlICYmIHR5cGVvZiB0aGlzLmFjdGl2ZU5vZGUucm93ID09PSAnbnVtYmVyJyA/IHJvd0luZGV4ID4gdGhpcy5hY3RpdmVOb2RlLnJvdyA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY2JIYW5kbGVyID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxJbkNoaWxkKHJvd0luZGV4LCBpc05leHQpO1xuICAgICAgICAgICAgICAgIGNiKGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0geyByb3c6IG51bGwsIGNvbHVtbjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXIubmF2aWdhdGVJbkJvZHkocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2JIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSB7IHJvdzogbnVsbCwgY29sdW1uOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmF2aWdhdGVJbkJvZHkocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2IpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzaG91bGRQZXJmb3JtVmVydGljYWxTY3JvbGwoaW5kZXgsIHZpc2libGVDb2x1bW5JbmRleCA9IC0xLCBpc05leHQ/KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFJlYyA9IHRoaXMuZ3JpZC5kYXRhVmlld1tpbmRleF07XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNDaGlsZEdyaWRSZWNvcmQodGFyZ2V0UmVjKSkge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbEZvckluZGV4KGluZGV4LCAhaXNOZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJTY3JvbGwgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gIWlzTmV4dCA/IHNjcm9sbEFtb3VudCA+IGN1cnJTY3JvbGwgOiBjdXJyU2Nyb2xsIDwgc2Nyb2xsQW1vdW50O1xuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFNjcm9sbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5zaG91bGRQZXJmb3JtVmVydGljYWxTY3JvbGwoaW5kZXgsIHZpc2libGVDb2x1bW5JbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZm9jdXNUYm9keShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSB8fCB0aGlzLmFjdGl2ZU5vZGUucm93ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgcm93OiAwLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRlVG8oMCwgMCwgKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5jbGVhckNlbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBvYmoudGFyZ2V0LmFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5mb2N1c1Rib2R5KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBuZXh0U2libGluZ0luZGV4KGlzTmV4dCkge1xuICAgICAgICBjb25zdCBsYXlvdXRLZXkgPSB0aGlzLmdyaWQuY2hpbGRSb3cubGF5b3V0LmtleTtcbiAgICAgICAgY29uc3QgbGF5b3V0SW5kZXggPSB0aGlzLmdyaWQucGFyZW50LmNoaWxkTGF5b3V0S2V5cy5pbmRleE9mKGxheW91dEtleSk7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGlzTmV4dCA/IGxheW91dEluZGV4ICsgMSA6IGxheW91dEluZGV4IC0gMTtcbiAgICAgICAgaWYgKG5leHRJbmRleCA8PSB0aGlzLmdyaWQucGFyZW50LmNoaWxkTGF5b3V0S2V5cy5sZW5ndGggLSAxICYmIG5leHRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNjcm9sbGluZyBpbiBjaGlsZCBncmlkIGFuZCBlbnN1cmVzIHRhcmdldCBjaGlsZCByb3cgaXMgaW4gbWFpbiBncmlkIHZpZXcgcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleCBUaGUgcm93IGluZGV4IHdoaWNoIHNob3VsZCBiZSBpbiB2aWV3LlxuICAgICAqIEBwYXJhbSBpc05leHQgIE9wdGlvbmFsLiBXaGV0aGVyIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIG5leHQuIFVzZWQgdG8gZGV0ZXJtaW5lIHNjcm9sbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIGNiICBPcHRpb25hbC5DYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVTY3JvbGxJbkNoaWxkKHJvd0luZGV4OiBudW1iZXIsIGlzTmV4dD86IGJvb2xlYW4sIGNiPzogKCkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSB0aGlzLnNob3VsZFBlcmZvcm1WZXJ0aWNhbFNjcm9sbChyb3dJbmRleCwgLTEsIGlzTmV4dCk7XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLnBlcmZvcm1WZXJ0aWNhbFNjcm9sbFRvQ2VsbChyb3dJbmRleCwgLTEsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uSW5QYXJlbnQocm93SW5kZXgsIGlzTmV4dCwgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uSW5QYXJlbnQocm93SW5kZXgsIGlzTmV4dCwgY2IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SW5kZXggUm93IGluZGV4IHRoYXQgc2hvdWxkIGNvbWUgaW4gdmlldy5cbiAgICAgKiBAcGFyYW0gaXNOZXh0ICBXaGV0aGVyIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIG5leHQuIFVzZWQgdG8gZGV0ZXJtaW5lIHNjcm9sbCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIGNiICBPcHRpb25hbC5DYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBvc2l0aW9uSW5QYXJlbnQocm93SW5kZXgsIGlzTmV4dCwgY2I/OiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHJvd09iaiA9IHRoaXMuZ3JpZC5ncmlkQVBJLmdldF9yb3dfYnlfaW5kZXgocm93SW5kZXgpO1xuICAgICAgICBpZiAoIXJvd09iaikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSB0aGlzLmdldFBvc2l0aW9uSW5mbyhyb3dPYmosIGlzTmV4dCk7XG4gICAgICAgIGlmICghcG9zaXRpb25JbmZvLmluVmlldykge1xuICAgICAgICAgICAgLy8gc3RvcCBldmVudCBmcm9tIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHNjcm9sbGluZyBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGFibGVHcmlkID0gaXNOZXh0ID8gdGhpcy5nZXROZXh0U2Nyb2xsYWJsZURvd24odGhpcy5ncmlkKSA6IHRoaXMuZ2V0TmV4dFNjcm9sbGFibGVVcCh0aGlzLmdyaWQpO1xuICAgICAgICAgICAgc2Nyb2xsYWJsZUdyaWQuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICAgICAgc2Nyb2xsYWJsZUdyaWQuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5hZGRTY3JvbGxUb3AocG9zaXRpb25JbmZvLm9mZnNldCk7XG4gICAgICAgICAgICBzY3JvbGxhYmxlR3JpZC5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmNodW5rTG9hZC5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBuYXZpZ2F0aW9uIHRvIGNoaWxkIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50Um93SW5kZXggVGhlIHBhcmVudCByb3cgaW5kZXgsIGF0IHdoaWNoIHRoZSBjaGlsZCBncmlkIGlzIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBjaGlsZExheW91dEluZGV4IE9wdGlvbmFsLiBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHJvdyBpc2xhbmQgdG8gd2hpY2ggdGhlIGNoaWxkIGdyaWQgYmVsb25ncyB0by4gVXNlcyBmaXJzdCBpZiBub3Qgc2V0LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbW92ZVRvQ2hpbGQocGFyZW50Um93SW5kZXg6IG51bWJlciwgdmlzaWJsZUNvbEluZGV4OiBudW1iZXIsIGlzTmV4dDogYm9vbGVhbiwgY2hpbGRMYXlvdXRJbmRleD86IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYj86IChhcmc6IGFueSkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCByaSA9IHR5cGVvZiBjaGlsZExheW91dEluZGV4ICE9PSAnbnVtYmVyJyA/XG4gICAgICAgICB0aGlzLmdyaWQuY2hpbGRMYXlvdXRMaXN0LmZpcnN0IDogdGhpcy5ncmlkLmNoaWxkTGF5b3V0TGlzdC50b0FycmF5KClbY2hpbGRMYXlvdXRJbmRleF07XG4gICAgICAgIGNvbnN0IHJvd0lkID0gdGhpcy5ncmlkLmRhdGFWaWV3W3BhcmVudFJvd0luZGV4XS5yb3dJRDtcbiAgICAgICAgY29uc3QgcGF0aFNlZ21lbnQ6IElQYXRoU2VnbWVudCA9IHtcbiAgICAgICAgICAgIHJvd0lEOiByb3dJZCxcbiAgICAgICAgICAgIHJvd0lzbGFuZEtleTogcmkua2V5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoaWxkR3JpZCA9ICB0aGlzLmdyaWQuaGdyaWRBUEkuZ2V0Q2hpbGRHcmlkKFtwYXRoU2VnbWVudF0pO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGlzTmV4dCA/IDAgOiBjaGlsZEdyaWQuZGF0YVZpZXcubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVjID0gIGNoaWxkR3JpZC5kYXRhVmlld1t0YXJnZXRJbmRleF07XG4gICAgICAgIGlmICghdGFyZ2V0UmVjKSB7XG4gICAgICAgICAgICAvLyBpZiBubyB0YXJnZXQgcmVjLCB0aGVuIG1vdmUgb24gaW4gbmV4dCBzaWJsaW5nIG9yIHBhcmVudFxuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24ubmF2aWdhdGVJbkJvZHkodGFyZ2V0SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEdyaWQuaXNDaGlsZEdyaWRSZWNvcmQodGFyZ2V0UmVjKSkge1xuICAgICAgICAgICAgLy8gaWYgdGFyZ2V0IGlzIGEgY2hpbGQgZ3JpZCByZWNvcmQgc2hvdWxkIG1vdmUgaW50byBpdC5cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLmFjdGl2ZU5vZGUucm93ID0gbnVsbDtcbiAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLmFjdGl2ZU5vZGUgPSB7IHJvdzogdGFyZ2V0SW5kZXgsIGNvbHVtbjogdGhpcy5hY3RpdmVOb2RlLmNvbHVtbn07XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5faGFuZGxlU2Nyb2xsSW5DaGlsZCh0YXJnZXRJbmRleCwgaXNOZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0TGF5b3V0SW5kZXggPSBpc05leHQgPyAwIDogY2hpbGRHcmlkLmNoaWxkTGF5b3V0TGlzdC50b0FycmF5KCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5fbW92ZVRvQ2hpbGQodGFyZ2V0SW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNOZXh0LCB0YXJnZXRMYXlvdXRJbmRleCwgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZEdyaWROYXYgPSAgY2hpbGRHcmlkLm5hdmlnYXRpb247XG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGxhc3RWaXNpYmxlSW5kZXggPSBjaGlsZEdyaWROYXYubGFzdENvbHVtbkluZGV4O1xuICAgICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHZpc2libGVDb2xJbmRleCA8PSBsYXN0VmlzaWJsZUluZGV4ID8gdmlzaWJsZUNvbEluZGV4IDogbGFzdFZpc2libGVJbmRleDtcbiAgICAgICAgY2hpbGRHcmlkTmF2LmFjdGl2ZU5vZGUgPSB7IHJvdzogdGFyZ2V0SW5kZXgsIGNvbHVtbjogY29sdW1uSW5kZXh9O1xuICAgICAgICBjaGlsZEdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5faGFuZGxlU2Nyb2xsSW5DaGlsZCh0YXJnZXRJbmRleCwgaXNOZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGVUbyh0YXJnZXRJbmRleCwgY29sdW1uSW5kZXgsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgbmF2aWdhdGlvbiBiYWNrIHRvIHBhcmVudCBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0luZGV4XG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9tb3ZlVG9QYXJlbnQoaXNOZXh0OiBib29sZWFuLCBjb2x1bW5JbmRleCwgY2I/KSB7XG4gICAgICAgIGNvbnN0IGluZGV4SW5QYXJlbnQgPSB0aGlzLmdyaWQuY2hpbGRSb3cuaW5kZXg7XG4gICAgICAgIGNvbnN0IGhhc05leHRUYXJnZXQgPSB0aGlzLmhhc05leHRUYXJnZXQodGhpcy5ncmlkLnBhcmVudCwgaW5kZXhJblBhcmVudCwgaXNOZXh0KTtcbiAgICAgICAgaWYgKCFoYXNOZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckFjdGl2YXRpb24oKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Um93SW5kZXggPSAgaXNOZXh0ID8gaW5kZXhJblBhcmVudCArIDEgOiBpbmRleEluUGFyZW50IC0gMTtcbiAgICAgICAgY29uc3QgbGFzdFZpc2libGVJbmRleCA9IHRoaXMuZ3JpZC5wYXJlbnQubmF2aWdhdGlvbi5sYXN0Q29sdW1uSW5kZXg7XG4gICAgICAgIGNvbnN0IG5leHRDb2x1bW5JbmRleCA9IGNvbHVtbkluZGV4IDw9IGxhc3RWaXNpYmxlSW5kZXggPyBjb2x1bW5JbmRleCA6IGxhc3RWaXNpYmxlSW5kZXg7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2JGdW5jID0gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBjYihhcmdzKTtcbiAgICAgICAgICAgIGFyZ3MudGFyZ2V0LmdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWQucGFyZW50Lm5hdmlnYXRpb24ubmF2aWdhdGVJbkJvZHkodGFyZ2V0Um93SW5kZXgsIG5leHRDb2x1bW5JbmRleCwgY2JGdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIG9uIHRoZSByb3cgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHJvb3QgZ3JpZCB2aWV3IHBvcnQuXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb3cgaXMgaW4gdmlldyBhbmQgaXRzIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dPYmpcbiAgICAgKiBAcGFyYW0gaXNOZXh0XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFBvc2l0aW9uSW5mbyhyb3dPYmo6IElneFJvd0RpcmVjdGl2ZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPiwgaXNOZXh0OiBib29sZWFuKSB7XG4gICAgICAgIGxldCByb3dFbGVtID0gcm93T2JqLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChyb3dPYmogaW5zdGFuY2VvZiBJZ3hDaGlsZEdyaWRSb3dDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTGF5b3V0S2V5cyA9IHRoaXMuZ3JpZC5jaGlsZExheW91dEtleXM7XG4gICAgICAgICAgICBjb25zdCByaUtleSA9IGlzTmV4dCA/IGNoaWxkTGF5b3V0S2V5c1swXSA6IGNoaWxkTGF5b3V0S2V5c1tjaGlsZExheW91dEtleXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwYXRoU2VnbWVudDogSVBhdGhTZWdtZW50ID0ge1xuICAgICAgICAgICAgICAgIHJvd0lEOiByb3dPYmoucm93RGF0YS5yb3dJRCxcbiAgICAgICAgICAgICAgICByb3dJc2xhbmRLZXk6IHJpS2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRHcmlkID0gIHRoaXMuZ3JpZC5oZ3JpZEFQSS5nZXRDaGlsZEdyaWQoW3BhdGhTZWdtZW50XSk7XG4gICAgICAgICAgICByb3dFbGVtID0gY2hpbGRHcmlkLnRmb290Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JpZEJvdHRvbSA9IHRoaXMuX2dldE1pbkJvdHRvbSh0aGlzLmdyaWQpO1xuICAgICAgICBjb25zdCBkaWZmQm90dG9tID1cbiAgICAgICAgcm93RWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBncmlkQm90dG9tO1xuICAgICAgICBjb25zdCBncmlkVG9wID0gdGhpcy5fZ2V0TWF4VG9wKHRoaXMuZ3JpZCk7XG4gICAgICAgIGNvbnN0IGRpZmZUb3AgPSByb3dFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtXG4gICAgICAgIHJvd0VsZW0ub2Zmc2V0SGVpZ2h0IC0gZ3JpZFRvcDtcbiAgICAgICAgY29uc3QgaXNJblZpZXcgPSBpc05leHQgPyBkaWZmQm90dG9tIDw9IDAgOiBkaWZmVG9wID49IDA7XG4gICAgICAgIGNvbnN0IGNhbGNPZmZzZXQgPSAgaXNOZXh0ID8gZGlmZkJvdHRvbSA6IGRpZmZUb3A7XG5cbiAgICAgICAgcmV0dXJuIHsgaW5WaWV3OiBpc0luVmlldywgb2Zmc2V0OiBjYWxjT2Zmc2V0IH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjbG9zZXN0IGVsZW1lbnQgYnkgaXRzIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZUVsZW0gVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB0YXJnZXRUYWcgVGhlIHRhcmdldCBlbGVtZW50IHRhZyBuYW1lLCBmb3Igd2hpY2ggdG8gc2VhcmNoLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDbG9zZXN0RWxlbUJ5VGFnKHNvdXJjZUVsZW0sIHRhcmdldFRhZykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc291cmNlRWxlbTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YXJnZXRUYWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyQWN0aXZhdGlvbigpIHtcbiAgICAgICAgLy8gY2xlYXIgaWYgcHJldmlvdXMgYWN0aXZhdGlvbiBleGlzdHMuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZS5yb3cgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNOZXh0VGFyZ2V0KGdyaWQsIGluZGV4OiBudW1iZXIsIGlzTmV4dDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCB0YXJnZXRSb3dJbmRleCA9ICBpc05leHQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGhhc1RhcmdldFJlY29yZCA9ICEhZ3JpZC5kYXRhVmlld1t0YXJnZXRSb3dJbmRleF07XG4gICAgICAgIGlmIChoYXNUYXJnZXRSZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGhhc1RhcmdldFJlY29yZEluUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZ3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEluUGFyZW50ID0gZ3JpZC5jaGlsZFJvdy5pbmRleDtcbiAgICAgICAgICAgICAgICBoYXNUYXJnZXRSZWNvcmRJblBhcmVudCA9IHRoaXMuaGFzTmV4dFRhcmdldChncmlkLnBhcmVudCwgaW5kZXhJblBhcmVudCwgaXNOZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNUYXJnZXRSZWNvcmRJblBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1heCB0b3AgdmlldyBpbiB0aGUgY3VycmVudCBncmlkIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0TWF4VG9wKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZDtcbiAgICAgICAgbGV0IHRvcCA9IGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICB3aGlsZSAoY3VyckdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFJvd3NIZWlnaHQgPSBjdXJyR3JpZC5oYXNQaW5uZWRSZWNvcmRzICYmIGN1cnJHcmlkLmlzUm93UGlubmluZ1RvVG9wID8gY3VyckdyaWQucGlubmVkUm93SGVpZ2h0IDogMDtcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY3VyckdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBwaW5uZWRSb3dzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbiBib3R0b20gdmlldyBpbiB0aGUgY3VycmVudCBncmlkIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0TWluQm90dG9tKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICB3aGlsZSAoY3VyckdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFJvd3NIZWlnaHQgPSBjdXJyR3JpZC5oYXNQaW5uZWRSZWNvcmRzICYmICFjdXJyR3JpZC5pc1Jvd1Bpbm5pbmdUb1RvcCA/IGN1cnJHcmlkLnBpbm5lZFJvd0hlaWdodCA6IDA7XG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gcGlubmVkUm93c0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdHRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBncmlkIHRoYXQgYWxsb3dzIHNjcm9sbGluZyBkb3duLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgVGhlIGdyaWQgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dFNjcm9sbGFibGVEb3duKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZC5wYXJlbnQ7XG4gICAgICAgIGlmICghY3VyckdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGdyaWQsIHByZXY6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGxldCBzY3JvbGxIZWlnaHQgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGwoKS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIGxldCBub25TY3JvbGxhYmxlID0gc2Nyb2xsSGVpZ2h0ID09PSAwIHx8XG4gICAgICAgICAgICBNYXRoLnJvdW5kKHNjcm9sbFRvcCArIGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgIGxldCBwcmV2ID0gZ3JpZDtcbiAgICAgICAgd2hpbGUgKG5vblNjcm9sbGFibGUgJiYgY3VyckdyaWQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VyckdyaWQ7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgbm9uU2Nyb2xsYWJsZSA9IHNjcm9sbEhlaWdodCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc2Nyb2xsVG9wICsgY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuaWd4Rm9yQ29udGFpbmVyU2l6ZSkgPT09IHNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmlkOiBjdXJyR3JpZCwgcHJldiB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IGdyaWQgdGhhdCBhbGxvd3Mgc2Nyb2xsaW5nIHVwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgVGhlIGdyaWQgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dFNjcm9sbGFibGVVcChncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQucGFyZW50O1xuICAgICAgICBpZiAoIWN1cnJHcmlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBncmlkLCBwcmV2OiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vblNjcm9sbGFibGUgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zY3JvbGxQb3NpdGlvbiA9PT0gMDtcbiAgICAgICAgbGV0IHByZXYgPSBncmlkO1xuICAgICAgICB3aGlsZSAobm9uU2Nyb2xsYWJsZSAmJiBjdXJyR3JpZC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXYgPSBjdXJyR3JpZDtcbiAgICAgICAgICAgIGN1cnJHcmlkID0gY3VyckdyaWQucGFyZW50O1xuICAgICAgICAgICAgbm9uU2Nyb2xsYWJsZSA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdyaWQ6IGN1cnJHcmlkLCBwcmV2IH07XG4gICAgfVxufVxuIl19