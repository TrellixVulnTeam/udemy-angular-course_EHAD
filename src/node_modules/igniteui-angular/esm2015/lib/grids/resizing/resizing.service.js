import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 * @internal
 */
export class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
        return actualWidth - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const maxWidth = this.column.maxWidthPx;
        if (this.column.maxWidth) {
            return maxWidth - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        this.column.width = this.column.getAutoSize();
        this.zone.run(() => { });
        this.column.grid.columnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        const colWidth = this.column.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        let currentColWidth = parseFloat(colWidth);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else if (isPercentageWidth) {
            this._handlePercentageResize(diff, this.column);
        }
        else {
            this._handlePixelResize(diff, this.column);
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.columnResized.emit({
                column: this.column,
                prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    _handlePixelResize(diff, column) {
        const currentColWidth = parseFloat(column.width);
        const colMinWidth = column.minWidthPx;
        const colMaxWidth = column.maxWidthPx;
        if (currentColWidth + diff < colMinWidth) {
            column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            column.width = colMaxWidth + 'px';
        }
        else {
            column.width = (currentColWidth + diff) + 'px';
        }
    }
    _handlePercentageResize(diff, column) {
        const currentPercentWidth = parseFloat(column.width);
        const gridAvailableSize = column.grid.calcWidth;
        const diffPercentage = (diff / gridAvailableSize) * 100;
        const colMinWidth = column.minWidthPercent;
        const colMaxWidth = column.maxWidthPercent;
        if (currentPercentWidth + diffPercentage < colMinWidth) {
            column.width = colMinWidth + '%';
        }
        else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
            column.width = colMaxWidth + '%';
        }
        else {
            column.width = (currentPercentWidth + diffPercentage) + '%';
        }
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const colWidth = col.target.width;
                const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                const minWidth = col.target.minWidthPx;
                const maxWidth = col.target.maxWidthPx;
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            const colWidth = col.target.width;
            const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._handlePercentageResize(resizeScaled, col.target);
            }
            else {
                this._handlePixelResize(resizeScaled, col.target);
            }
        });
    }
}
IgxColumnResizingService.decorators = [
    { type: Injectable }
];
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9yZXNpemluZy9yZXNpemluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBR25EOzs7R0FHRztBQUVILE1BQU0sT0FBTyx3QkFBd0I7SUF1QmpDLFlBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBYmhDOztXQUVHO1FBQ0ksaUJBQVksR0FBVyxJQUFJLENBQUM7UUFDbkM7O1dBRUc7UUFDSSxnQkFBVyxHQUFHLEtBQUssQ0FBQztJQU1TLENBQUM7SUFFckM7O09BRUc7SUFDRixJQUFXLGFBQWE7UUFDckIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztRQUV4RCxvSEFBb0g7UUFDcEgsSUFBSSxzQkFBc0IsR0FBRyxDQUFDLENBQUM7UUFDL0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFO1lBQy9CLHNCQUFzQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztTQUM5RjtRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxzQkFBc0IsQ0FBQztTQUNySDtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FF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WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILG1CQUFtQixHQUFHLGVBQWUsQ0FBQztZQUN0QyxlQUFlLEdBQUcsZUFBZSxDQUFDO1NBQ3JDLFFBQVEsYUFBYSxFQUFFO1FBRXhCLGlFQUFpRTtRQUNqRSxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsTUFBTSxZQUFZLEdBQUcsQ0FBQyxXQUFXLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQztZQUNyRixNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztZQUNsQyxNQUFNLGlCQUFpQixHQUFHLFFBQVEsSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNuRyxJQUFJLGlCQUFpQixFQUFFO2dCQUNuQixJQUFJLENBQUMsdUJBQXVCLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMxRDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNyRDtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7O1lBdk5KLFVBQVU7OztZQVBVLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydFJlc2l6ZVBvczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgY29sdW1uIGlzIGN1cnJlbnRseSBiZWluZyByZXNpemVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NvbHVtblJlc2l6aW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ3Vyc29yOiBzdHJpbmcgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgICBwdWJsaWMgZ2V0IHJlc2l6ZXJIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuY29sdW1uLmdyaWQuZ2V0VmlzaWJsZUNvbnRlbnRIZWlnaHQoKTtcblxuICAgICAgICAvLyBDb2x1bW4gaGVpZ2h0IG11bHRpcGxpZXIgaW4gY2FzZSB0aGVyZSBhcmUgQ29sdW1uIExheW91dHMuIFRoZSByZXNpemVyIGhlaWdodCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHJvd1N0YXJ0LlxuICAgICAgICBsZXQgY29sdW1uSGVpZ2h0TXVsdGlwbGllciA9IDE7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgY29sdW1uSGVpZ2h0TXVsdGlwbGllciA9IHRoaXMuY29sdW1uLmdyaWQubXVsdGlSb3dMYXlvdXRSb3dTaXplIC0gdGhpcy5jb2x1bW4ucm93U3RhcnQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmxldmVsICE9PSAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgLT0gdGhpcy5jb2x1bW4udG9wTGV2ZWxQYXJlbnQuaGVhZGVyR3JvdXAuaGVpZ2h0IC0gdGhpcy5jb2x1bW4uaGVhZGVyR3JvdXAuaGVpZ2h0ICogY29sdW1uSGVpZ2h0TXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWluaW1hbCBwb3NzaWJsZSB3aWR0aCB0byB3aGljaCB0aGUgY29sdW1uIGNhbiBiZSByZXNpemVkLlxuICAgICAqL1xuICAgICBwdWJsaWMgZ2V0IHJlc3RyaWN0UmVzaXplTWluKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gdGhpcy5jb2x1bW4ubWluV2lkdGhQeCA8IGFjdHVhbFdpZHRoID8gdGhpcy5jb2x1bW4ubWluV2lkdGhQeCA6IGFjdHVhbFdpZHRoO1xuXG4gICAgICAgIHJldHVybiBhY3R1YWxXaWR0aCAtIG1pbldpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICAgcHVibGljIGdldCByZXN0cmljdFJlc2l6ZU1heCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuY29sdW1uLm1heFdpZHRoUHg7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5tYXhXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoIC0gYWN0dWFsV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2l6ZXMgdGhlIGNvbHVtbiB0byB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIElmIHRoZSBjb2x1bW4gaGFzIGEgcHJlZGlmaW5lZCBtYXhXaWR0aCBhbmQgdGhlIGF1dG9zaXplZCBjb2x1bW4gd2lkdGggd2lsbCBiZWNvbWUgYmlnZ2VyIHRoYW4gaXQsXG4gICAgICogdGhlbiB0aGUgY29sdW1uIGlzIHNpemVkIHRvIGl0cyBtYXhXaWR0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemVDb2x1bW5PbkRibENsaWNrKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSB0aGlzLmNvbHVtbi5nZXRBdXRvU2l6ZSgpO1xuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQuY29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNvbHVtbiByZWdhcmlkbmcgdG8gdGhlIGNvbHVtbiBtaW5XaWR0aCBhbmQgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFJlc2l6ZVBvcztcblxuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sV2lkdGgpO1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSA/IHBhcnNlRmxvYXQoYWN0dWFsV2lkdGgpIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5ncmlkLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ29sdW1uTGF5b3V0Rm9yKHRoaXMuY29sdW1uLCBkaWZmKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BlcmNlbnRhZ2VXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGVyY2VudGFnZVJlc2l6ZShkaWZmLCB0aGlzLmNvbHVtbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVQaXhlbFJlc2l6ZShkaWZmLCB0aGlzLmNvbHVtbik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggIT09IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLmNvbHVtblJlc2l6ZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICBwcmV2V2lkdGg6IGlzUGVyY2VudGFnZVdpZHRoID8gY3VycmVudENvbFdpZHRoICsgJyUnIDogY3VycmVudENvbFdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0NvbHVtblJlc2l6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVQaXhlbFJlc2l6ZShkaWZmOiBudW1iZXIsIGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgY29sTWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGhQeDtcbiAgICAgICAgY29uc3QgY29sTWF4V2lkdGggPSBjb2x1bW4ubWF4V2lkdGhQeDtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPCBjb2xNaW5XaWR0aCkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWluV2lkdGggKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbE1heFdpZHRoICYmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmID4gY29sTWF4V2lkdGgpKSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBjb2xNYXhXaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSAoY3VycmVudENvbFdpZHRoICsgZGlmZikgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVQZXJjZW50YWdlUmVzaXplKGRpZmY6IG51bWJlciwgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBlcmNlbnRXaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSBjb2x1bW4uZ3JpZC5jYWxjV2lkdGg7XG5cbiAgICAgICAgY29uc3QgZGlmZlBlcmNlbnRhZ2UgPSAoZGlmZiAvIGdyaWRBdmFpbGFibGVTaXplKSAqIDEwMDtcbiAgICAgICAgY29uc3QgY29sTWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGhQZXJjZW50O1xuICAgICAgICBjb25zdCBjb2xNYXhXaWR0aCA9ICBjb2x1bW4ubWF4V2lkdGhQZXJjZW50O1xuXG4gICAgICAgIGlmIChjdXJyZW50UGVyY2VudFdpZHRoICsgZGlmZlBlcmNlbnRhZ2UgPCBjb2xNaW5XaWR0aCkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWluV2lkdGggKyAnJSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sTWF4V2lkdGggJiYgKGN1cnJlbnRQZXJjZW50V2lkdGggKyBkaWZmUGVyY2VudGFnZSA+IGNvbE1heFdpZHRoKSkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWF4V2lkdGggKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSAoY3VycmVudFBlcmNlbnRXaWR0aCArIGRpZmZQZXJjZW50YWdlKSArICclJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2xNaW5XaWR0aChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ud2lkdGgpO1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IGNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gTnVtYmVyLmlzTmFOKGN1cnJlbnRDb2xXaWR0aCkgfHwgKGN1cnJlbnRDb2xXaWR0aCA8IGFjdHVhbFdpZHRoKSA/IGFjdHVhbFdpZHRoIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGNvbnN0IGFjdHVhbE1pbldpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ubWluV2lkdGgpO1xuICAgICAgICByZXR1cm4gYWN0dWFsTWluV2lkdGggPCBjdXJyZW50Q29sV2lkdGggPyBhY3R1YWxNaW5XaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVzaXplQ29sdW1uTGF5b3V0Rm9yKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50LCBkaWZmOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVDb2x1bW5zID0gY29sdW1uLmdldFJlc2l6YWJsZUNvbFVuZGVyRW5kKCk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU3BhbiA9IHJlbGF0aXZlQ29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKSA9PiAgYWNjICsgY29sLnNwYW5Vc2VkLCAwKTtcblxuICAgICAgICAvLyBSZXNpemUgZmlyc3QgdGhvc2Ugd2hvIG1pZ2h0IHJlYWNoIG1pbi9tYXggd2lkdGhcbiAgICAgICAgbGV0IGNvbHVtbnNUb1Jlc2l6ZSA9IFsuLi5yZWxhdGl2ZUNvbHVtbnNdO1xuICAgICAgICBsZXQgdXBkYXRlZERpZmYgPSBkaWZmO1xuICAgICAgICBsZXQgdXBkYXRlZENvbWJpbmVkU3BhbiA9IGNvbWJpbmVkU3BhbjtcbiAgICAgICAgbGV0IHNldE1pbk1heENvbHMgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gQ3ljbGUgdGhlbSB1bnRpbCB0aGVyZSBhcmUgbm90IG9uZXMgdGhhdCByZWFjaCBtaW4vbWF4IHNpemUsIGJlY2F1c2UgdGhlIGRpZmYgYWNjdW11bGF0ZXMgYWZ0ZXIgZWFjaCBjeWNsZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBhdCBmaXJzdCAyIGNvbHMgcmVhY2hpbmcgbWluIHdpZHRoIGFuZCB0aGVuIGFmdGVyXG4gICAgICAgICAgICAvLyByZWNhbGN1bGF0aW5nIHRoZSBkaWZmIHRoZXJlIG1pZ2h0IGJlIDEgbW9yZSB0aGF0IHJlYWNoZXMgbWluIHdpZHRoLlxuICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5ld0NvbWJpbmVkU3BhbiA9IHVwZGF0ZWRDb21iaW5lZFNwYW47XG4gICAgICAgICAgICBjb25zdCBuZXdDb2xzVG9SZXNpemUgPSBbXTtcbiAgICAgICAgICAgIGNvbHVtbnNUb1Jlc2l6ZS5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzaXplV2lkdGggPSBwYXJzZUZsb2F0KGNvbC50YXJnZXQuY2FsY1dpZHRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNpemVTY2FsZWQgPSAoZGlmZiAvIHVwZGF0ZWRDb21iaW5lZFNwYW4pICogY29sLnRhcmdldC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xXaWR0aCA9IGNvbC50YXJnZXQud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSBjb2xXaWR0aCAmJiB0eXBlb2YgY29sV2lkdGggPT09ICdzdHJpbmcnICYmIGNvbFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtaW5XaWR0aCA9IGNvbC50YXJnZXQubWluV2lkdGhQeDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbC50YXJnZXQubWF4V2lkdGhQeDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkIDwgbWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnRhcmdldC53aWR0aCA9IGlzUGVyY2VudGFnZVdpZHRoID8gY29sLnRhcmdldC5taW5XaWR0aFBlcmNlbnQgKyAnJScgOiBtaW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWREaWZmICs9IChjdXJyZW50UmVzaXplV2lkdGggLSBtaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbWJpbmVkU3BhbiAtPSBjb2wuc3BhblVzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF4V2lkdGggJiYgKGN1cnJlbnRSZXNpemVXaWR0aCArIHJlc2l6ZVNjYWxlZCA+IG1heFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2wudGFyZ2V0LndpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyBjb2wudGFyZ2V0Lm1heFdpZHRoUGVyY2VudCArICclJyA6IGNvbC50YXJnZXQubWF4V2lkdGhQeCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWREaWZmIC09IChtYXhXaWR0aCAtIGN1cnJlbnRSZXNpemVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbWJpbmVkU3BhbiAtPSBjb2wuc3BhblVzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgbmV3IG9uZXMgdGhhdCBjYW4gYmUgcmVzaXplZFxuICAgICAgICAgICAgICAgICAgICBuZXdDb2xzVG9SZXNpemUucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1cGRhdGVkQ29tYmluZWRTcGFuID0gbmV3Q29tYmluZWRTcGFuO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplID0gbmV3Q29sc1RvUmVzaXplO1xuICAgICAgICB9IHdoaWxlIChzZXRNaW5NYXhDb2xzKTtcblxuICAgICAgICAvLyBUaG9zZSBsZWZ0IHRoYXQgZG9uJ3QgcmVhY2ggbWluL21heCBzaXplIHJlc2l6ZSB0aGVtIG5vcm1hbGx5LlxuICAgICAgICBjb2x1bW5zVG9SZXNpemUuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNpemVTY2FsZWQgPSAodXBkYXRlZERpZmYgLyB1cGRhdGVkQ29tYmluZWRTcGFuKSAqIGNvbC50YXJnZXQuZ3JpZENvbHVtblNwYW47XG4gICAgICAgICAgICBjb25zdCBjb2xXaWR0aCA9IGNvbC50YXJnZXQud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgICAgIGlmIChpc1BlcmNlbnRhZ2VXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBlcmNlbnRhZ2VSZXNpemUocmVzaXplU2NhbGVkLCBjb2wudGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUGl4ZWxSZXNpemUocmVzaXplU2NhbGVkLCBjb2wudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19