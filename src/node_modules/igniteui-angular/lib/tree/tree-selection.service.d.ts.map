{"version":3,"file":"tree-selection.service.d.ts","sources":["tree-selection.service.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { IgxTree, IgxTreeNode } from './common';\n/** @hidden @internal */\nexport declare class IgxTreeSelectionService {\n    private tree;\n    private nodeSelection;\n    private indeterminateNodes;\n    private nodesToBeSelected;\n    private nodesToBeIndeterminate;\n    register(tree: IgxTree): void;\n    /** Select range from last selected node to the current specified node. */\n    selectMultipleNodes(node: IgxTreeNode<any>, event?: Event): void;\n    /** Select the specified node and emit event. */\n    selectNode(node: IgxTreeNode<any>, event?: Event): void;\n    /** Deselect the specified node and emit event. */\n    deselectNode(node: IgxTreeNode<any>, event?: Event): void;\n    /** Clears node selection */\n    clearNodesSelection(): void;\n    isNodeSelected(node: IgxTreeNode<any>): boolean;\n    isNodeIndeterminate(node: IgxTreeNode<any>): boolean;\n    /** Select specified nodes. No event is emitted. */\n    selectNodesWithNoEvent(nodes: IgxTreeNode<any>[], clearPrevSelection?: boolean, shouldEmit?: boolean): void;\n    /** Deselect specified nodes. No event is emitted. */\n    deselectNodesWithNoEvent(nodes?: IgxTreeNode<any>[], shouldEmit?: boolean): void;\n    /** Called on `node.ngOnDestroy` to ensure state is correct after node is removed */\n    ensureStateOnNodeDelete(node: IgxTreeNode<any>): void;\n    /** Retriggers a node's selection state */\n    private retriggerNodeState;\n    /** Returns array of the selected nodes. */\n    private getSelectedNodes;\n    /** Returns array of the nodes in indeterminate state. */\n    private getIndeterminateNodes;\n    private emitNodeSelectionEvent;\n    private areEqualCollections;\n    private cascadeSelectNodesWithNoEvent;\n    private cascadeDeselectNodesWithNoEvent;\n    /**\n     * populates the nodesToBeSelected and nodesToBeIndeterminate sets\n     * with the nodes which will be eventually in selected/indeterminate state\n     */\n    private calculateNodesNewSelectionState;\n    /** Ensures proper selection state for all predescessors and descendants during a selection event */\n    private cascadeSelectionState;\n    private emitCascadeNodeSelectionEvent;\n    /**\n     * recursively handle the selection state of the direct and indirect parents\n     */\n    private handleParentSelectionState;\n    /**\n     * Handle the selection state of a given node based the selection states of its direct children\n     */\n    private handleNodeSelectionState;\n    /**\n     * Get a collection of all nodes affected by the change event\n     *\n     * @param nodesToBeProcessed set of the nodes to be selected/deselected\n     * @returns a collection of all affected nodes and all their parents\n     */\n    private getCascadingNodeCollection;\n    /**\n     * retrieve the nodes which should be added/removed to/from the old selection\n     */\n    private populateAddRemoveArgs;\n    /** Emits the `selectedChange` event for each node affected by the selection */\n    private emitSelectedChangeEvent;\n}\n"]}