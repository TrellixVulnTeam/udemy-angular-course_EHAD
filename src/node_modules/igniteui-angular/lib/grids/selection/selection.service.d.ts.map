{"version":3,"file":"selection.service.d.ts","sources":["selection.service.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, NgZone } from '@angular/core';\nimport { Subject } from 'rxjs';\nexport interface GridSelectionRange {\n    rowStart: number;\n    rowEnd: number;\n    columnStart: string | number;\n    columnEnd: string | number;\n}\nexport interface ISelectionNode {\n    row: number;\n    column: number;\n    layout?: IMultiRowLayoutNode;\n    isSummaryRow?: boolean;\n}\nexport interface IMultiRowLayoutNode {\n    rowStart: number;\n    colStart: number;\n    rowEnd: number;\n    colEnd: number;\n    columnVisibleIndex: number;\n}\ninterface ISelectionKeyboardState {\n    node: null | ISelectionNode;\n    shift: boolean;\n    range: GridSelectionRange;\n    active: boolean;\n}\ninterface ISelectionPointerState extends ISelectionKeyboardState {\n    ctrl: boolean;\n    primaryButton: boolean;\n}\ninterface IColumnSelectionState {\n    field: null | string;\n    range: string[];\n}\ndeclare type SelectionState = ISelectionKeyboardState | ISelectionPointerState;\nexport declare class IgxGridSelectionService {\n    private zone;\n    grid: any;\n    dragMode: boolean;\n    activeElement: ISelectionNode | null;\n    keyboardState: ISelectionKeyboardState;\n    pointerState: ISelectionPointerState;\n    columnsState: IColumnSelectionState;\n    selection: Map<number, Set<number>>;\n    temp: Map<number, Set<number>>;\n    rowSelection: Set<any>;\n    indeterminateRows: Set<any>;\n    columnSelection: Set<string>;\n    /**\n     * @hidden @internal\n     */\n    selectedRowsChange: Subject<unknown>;\n    /**\n     * Toggled when a pointerdown event is triggered inside the grid body (cells).\n     * When `false` the drag select behavior is disabled.\n     */\n    private pointerEventInGridBody;\n    private allRowsSelected;\n    private _ranges;\n    private _selectionRange;\n    /**\n     * Returns the current selected ranges in the grid from both\n     * keyboard and pointer interactions\n     */\n    get ranges(): GridSelectionRange[];\n    get primaryButton(): boolean;\n    set primaryButton(value: boolean);\n    constructor(zone: NgZone);\n    /**\n     * Resets the keyboard state\n     */\n    initKeyboardState(): void;\n    /**\n     * Resets the pointer state\n     */\n    initPointerState(): void;\n    /**\n     * Resets the columns state\n     */\n    initColumnsState(): void;\n    /**\n     * Adds a single node.\n     * Single clicks | Ctrl + single clicks on cells is the usual case.\n     */\n    add(node: ISelectionNode, addToRange?: boolean): void;\n    /**\n     * Adds the active keyboard range selection (if any) to the `ranges` meta.\n     */\n    addKeyboardRange(): void;\n    remove(node: ISelectionNode): void;\n    isInMap(node: ISelectionNode): boolean;\n    selected(node: ISelectionNode): boolean;\n    isActiveNode(node: ISelectionNode): boolean;\n    isActiveLayout(current: IMultiRowLayoutNode, target: IMultiRowLayoutNode): boolean;\n    addRangeMeta(node: ISelectionNode, state?: SelectionState): void;\n    removeRangeMeta(node: ISelectionNode, state?: SelectionState): void;\n    /**\n     * Generates a new selection range from the given `node`.\n     * If `state` is passed instead it will generate the range based on the passed `node`\n     * and the start node of the `state`.\n     */\n    generateRange(node: ISelectionNode, state?: SelectionState): GridSelectionRange;\n    /**\n     *\n     */\n    keyboardStateOnKeydown(node: ISelectionNode, shift: boolean, shiftTab: boolean): void;\n    keyboardStateOnFocus(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>, dom: any): void;\n    pointerDown(node: ISelectionNode, shift: boolean, ctrl: boolean): void;\n    pointerDownShiftKey(node: ISelectionNode): void;\n    mergeMap(target: Map<number, Set<number>>, source: Map<number, Set<number>>): void;\n    pointerEnter(node: ISelectionNode, event: PointerEvent): boolean;\n    pointerUp(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>): boolean;\n    selectRange(node: ISelectionNode, state: SelectionState, collection?: Map<number, Set<number>>): void;\n    dragSelect(node: ISelectionNode, state: SelectionState): void;\n    clear(clearAcriveEl?: boolean): void;\n    clearTextSelection(): void;\n    restoreTextSelection(): void;\n    /** Returns array of the selected row id's. */\n    getSelectedRows(): Array<any>;\n    /** Returns array of the rows in indeterminate state. */\n    getIndeterminateRows(): Array<any>;\n    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */\n    clearRowSelection(event?: any): void;\n    /** Select all rows, if filtering is applied select only from filtered data. */\n    selectAllRows(event?: any): void;\n    /** Select the specified row and emit event. */\n    selectRowById(rowID: any, clearPrevSelection?: any, event?: any): void;\n    /** Deselect the specified row and emit event. */\n    deselectRow(rowID: any, event?: any): void;\n    /** Select specified rows. No event is emitted. */\n    selectRowsWithNoEvent(rowIDs: any[], clearPrevSelection?: any): void;\n    /** Deselect specified rows. No event is emitted. */\n    deselectRowsWithNoEvent(rowIDs: any[]): void;\n    isRowSelected(rowID: any): boolean;\n    isRowInIndeterminateState(rowID: any): boolean;\n    /** Select range from last selected row to the current specified row. */\n    selectMultipleRows(rowID: any, rowData: any, event?: any): void;\n    areAllRowSelected(): boolean;\n    hasSomeRowSelected(): boolean;\n    get filteredSelectedRowIds(): any[];\n    emitRowSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;\n    getRowDataById(rowID: any): any;\n    getRowIDs(data: any): Array<any>;\n    clearHeaderCBState(): void;\n    /** Clear rowSelection and update checkbox state */\n    clearAllSelectedRows(): void;\n    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */\n    get allData(): Array<any>;\n    /** Returns array of the selected columns fields. */\n    getSelectedColumns(): Array<any>;\n    isColumnSelected(field: string): boolean;\n    /** Select the specified column and emit event. */\n    selectColumn(field: string, clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;\n    /** Select specified columns. And emit event. */\n    selectColumns(fields: string[], clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;\n    /** Select range from last clicked column to the current specified column. */\n    selectColumnsRange(field: string, event: any): void;\n    /** Select specified columns. No event is emitted. */\n    selectColumnsWithNoEvent(fields: string[], clearPrevSelection?: any): void;\n    /** Deselect the specified column and emit event. */\n    deselectColumn(field: string, event?: any): void;\n    /** Deselect specified columns. No event is emitted. */\n    deselectColumnsWithNoEvent(fields: string[]): void;\n    /** Deselect specified columns. And emit event. */\n    deselectColumns(fields: string[], event?: any): void;\n    emitColumnSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;\n    /** Clear columnSelection */\n    clearAllSelectedColumns(): void;\n    protected areEqualCollections(first: any, second: any): boolean;\n    /**\n     * (╯°□°）╯︵ ┻━┻\n     * Chrome and Chromium don't care about the active\n     * range after keyboard navigation, thus this.\n     */\n    private _moveSelectionChrome;\n    private isFilteringApplied;\n    private isRowDeleted;\n    private pointerOriginHandler;\n}\nexport declare const isChromium: () => boolean;\nexport {};\n"]}