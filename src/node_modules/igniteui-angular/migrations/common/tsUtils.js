"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMemberIgniteUI = exports.getTypeDefinitionAtPosition = exports.createProjectService = exports.getLanguageService = exports.replaceMatch = exports.findMatches = exports.getRenamePositions = exports.getImportModulePositions = exports.getIdentifierPositions = exports.CUSTOM_TS_PLUGIN_NAME = exports.CUSTOM_TS_PLUGIN_PATH = exports.NG_CORE_PACKAGE_NAME = exports.NG_LANG_SERVICE_PACKAGE_NAME = exports.IG_PACKAGE_NAME = void 0;
// eslint-disable-next-line import/no-extraneous-dependencies
const ts = require("typescript");
const tss = require("typescript/lib/tsserverlibrary");
const util_1 = require("./util");
const tsLogger_1 = require("./tsLogger");
exports.IG_PACKAGE_NAME = 'igniteui-angular';
exports.NG_LANG_SERVICE_PACKAGE_NAME = '@angular/language-service';
exports.NG_CORE_PACKAGE_NAME = '@angular/core';
exports.CUSTOM_TS_PLUGIN_PATH = './tsPlugin';
exports.CUSTOM_TS_PLUGIN_NAME = 'igx-ts-plugin';
/** Returns a source file */
// export function getFileSource(sourceText: string): ts.SourceFile {
//     return ts.createSourceFile('', sourceText, ts.ScriptTarget.Latest, true);
// }
const getIdentifierPositions = (source, name) => {
    if (typeof source === 'string') {
        source = ts.createSourceFile('', source, ts.ScriptTarget.Latest, true);
    }
    const positions = [];
    const checkIdentifier = (node) => {
        if (!ts.isIdentifier(node) || !node.parent) {
            return false;
        }
        if (node.parent.kind === ts.SyntaxKind.PropertyDeclaration) {
            // `const identifier = ...`
            return false;
        }
        if (ts.isPropertyAssignment(node.parent) || ts.isPropertySignature(node.parent)) {
            // make sure it's not prop assign  `= { IgxClass: "fake"}`
            //                  definition `prop: { IgxClass: string; }`
            //                                     name: initializer
            if (node.parent.name.getText() === name) {
                return false;
            }
        }
        return node.text === name;
    };
    const findIdentifiers = (node) => {
        if (checkIdentifier(node)) {
            // Use `.getStart()` as node.pos includes the space(s) before the identifier text
            positions.push({ start: node.getStart(), end: node.end });
        }
        ts.forEachChild(node, findIdentifiers);
    };
    source.forEachChild(findIdentifiers);
    return positions;
};
exports.getIdentifierPositions = getIdentifierPositions;
/** Returns the positions of import from module string literals  */
const getImportModulePositions = (sourceText, startsWith) => {
    const source = ts.createSourceFile('', sourceText, ts.ScriptTarget.Latest, true);
    const positions = [];
    for (const statement of source.statements) {
        if (statement.kind === ts.SyntaxKind.ImportDeclaration) {
            const specifier = statement.moduleSpecifier;
            if (specifier.text.startsWith(startsWith)) {
                // string literal pos will include quotes, trim with 1
                positions.push({ start: specifier.getStart() + 1, end: specifier.end - 1 });
            }
        }
    }
    return positions;
};
exports.getImportModulePositions = getImportModulePositions;
/** Filters out statements to named imports (e.g. `import {x, y}`) from PACKAGE_IMPORT */
const namedImportFilter = (statement) => {
    if (statement.kind === ts.SyntaxKind.ImportDeclaration &&
        statement.moduleSpecifier.text.endsWith(exports.IG_PACKAGE_NAME)) {
        const clause = statement.importClause;
        return clause && clause.namedBindings && clause.namedBindings.kind === ts.SyntaxKind.NamedImports;
    }
    return false;
};
const getRenamePositions = (sourcePath, name, service) => {
    const source = service.getProgram().getSourceFile(sourcePath);
    const positions = [];
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const imports = source.statements.filter(namedImportFilter);
    if (!imports.length) {
        return positions;
    }
    const elements = imports
        .map(x => x.importClause.namedBindings.elements)
        .reduce((prev, current) => prev.concat(current));
    for (const elem of elements) {
        if (elem.propertyName && elem.propertyName.text === name) {
            // alias imports `igxClass as smth` -> <propertyName> as <name>
            // other references are only for the name portion
            positions.push({ start: elem.propertyName.getStart(), end: elem.propertyName.getEnd() });
            break;
        }
        if (!elem.propertyName && elem.name.text === name) {
            const renames = service.findRenameLocations(sourcePath, elem.name.getStart(), false, false, false);
            if (renames) {
                const renamesPos = renames.map(x => ({ start: x.textSpan.start, end: x.textSpan.start + x.textSpan.length }));
                positions.push(...renamesPos);
            }
        }
    }
    return positions;
};
exports.getRenamePositions = getRenamePositions;
const findMatches = (content, toFind) => {
    let matches;
    const regex = new RegExp(util_1.escapeRegExp(toFind), 'g');
    const matchesPositions = [];
    do {
        matches = regex.exec(content);
        if (matches) {
            matchesPositions.push(matches.index);
        }
    } while (matches);
    return matchesPositions;
};
exports.findMatches = findMatches;
const replaceMatch = (content, toReplace, replaceWith, index) => content.substring(0, index) +
    replaceWith +
    content.substring(index + toReplace.length, content.length);
exports.replaceMatch = replaceMatch;
//#region Language Service
/**
 * Create a TypeScript language service
 *
 * @param serviceHost A TypeScript language service host
 */
const getLanguageService = (filePaths, host, options = {}) => {
    const fileVersions = new Map();
    patchHostOverwrite(host, fileVersions);
    const servicesHost = {
        getCompilationSettings: () => options,
        getScriptFileNames: () => filePaths,
        getScriptVersion: fileName => {
            // return host.actions.filter(x => x.path === fileName && x.kind !== 'c').length.toString();
            const version = fileVersions.get(fileName) || 0;
            return version.toString();
        },
        getScriptSnapshot: fileName => {
            if (!host.exists(fileName)) {
                return undefined;
            }
            return ts.ScriptSnapshot.fromString(host.read(fileName).toString());
        },
        getCurrentDirectory: () => process.cwd(),
        getDefaultLibFileName: opts => ts.getDefaultLibFilePath(opts),
        fileExists: fileName => filePaths.indexOf(fileName) !== -1
    };
    return ts.createLanguageService(servicesHost, ts.createDocumentRegistry());
};
exports.getLanguageService = getLanguageService;
const patchHostOverwrite = (host, fileVersions) => {
    const original = host.overwrite;
    host.overwrite = (path, content) => {
        const version = fileVersions.get(path) || 0;
        fileVersions.set(path, version + 1);
        original.call(host, path, content);
    };
};
/**
 * Create a project service singleton that holds all projects within a directory tree
 *
 * @param serverHost Used by the tss to navigate the directory tree
 */
const createProjectService = (serverHost) => {
    // set traceToConsole to true to enable logging
    const logger = new tsLogger_1.Logger(false, tss.server.LogLevel.verbose);
    const projectService = new tss.server.ProjectService({
        host: serverHost,
        logger,
        /* not needed since we will run only migrations */
        cancellationToken: tss.server.nullCancellationToken,
        /* do not allow more than one InferredProject per project root */
        useSingleInferredProject: true,
        useInferredProjectPerProjectRoot: true,
        /* will load only global plug-ins */
        globalPlugins: [exports.CUSTOM_TS_PLUGIN_NAME, exports.NG_LANG_SERVICE_PACKAGE_NAME],
        allowLocalPluginLoads: false,
        typingsInstaller: tss.server.nullTypingsInstaller
    });
    projectService.setHostConfiguration({
        formatOptions: projectService.getHostFormatCodeOptions(),
        extraFileExtensions: [
            {
                extension: '.html',
                isMixedContent: false,
                scriptKind: tss.ScriptKind.External,
            }
        ]
    });
    projectService.configurePlugin({
        pluginName: exports.CUSTOM_TS_PLUGIN_NAME,
        configuration: {}
    });
    projectService.configurePlugin({
        pluginName: exports.NG_LANG_SERVICE_PACKAGE_NAME,
        configuration: {
            ivy: true,
            angularOnly: false,
        },
    });
    return projectService;
};
exports.createProjectService = createProjectService;
/**
 * Attempts to get type definitions using the TypeScript Language Service.
 * Can fall back to a cached version of the TSLS.
 */
const getTypeDefinitions = (langServ, entryPath, position) => 
/*
    getTypeScriptLanguageService is attached by us to the Typescript Language Service
    via a custom made plugin, it's sole purpose is to cache the language service and return it
    before any other plugins modify it
*/
langServ.getTypeDefinitionAtPosition(entryPath, position)
    || langServ.getTypeScriptLanguageService().getTypeDefinitionAtPosition(entryPath, position);
/**
 * Get type information about a TypeScript identifier
 *
 * @param langServ TypeScript/Angular LanguageService
 * @param entryPath path to file
 * @param position Index of identifier
 */
const getTypeDefinitionAtPosition = (langServ, entryPath, position) => {
    var _a, _b;
    const definition = (_a = langServ.getDefinitionAndBoundSpan(entryPath, position)) === null || _a === void 0 ? void 0 : _a.definitions[0];
    if (!definition) {
        return null;
    }
    // if the definition's kind is a reference, the identifier is a template variable referred in an internal/external template
    if (definition.kind.toString() === 'reference') {
        return langServ.getDefinitionAndBoundSpan(entryPath, definition.textSpan.start).definitions[0];
    }
    if (definition.kind.toString() === 'method') {
        // TODO:
        // const typeChecker = langServ.getProgram().getTypeChecker();
        // typeChecker.getSymbolAtLocation() // need getTokenAtPosition / adapted getTokenAtPositionWorker from ts
        // typeChecker.getReturnTypeOfSignature()
        const maybeReturnType = (_b = langServ.getQuickInfoAtPosition(entryPath, position).displayParts) === null || _b === void 0 ? void 0 : _b.pop();
        // quick info (and getImplementationAtPosition) have the return type as last of the displayParts
        // check if it's a className (potentially Ignite comp) and use for definition name:
        definition.name = maybeReturnType.kind === 'className' ? maybeReturnType.text : '';
        return definition;
    }
    let typeDefs = getTypeDefinitions(langServ, definition.fileName || entryPath, definition.textSpan.start);
    // if there are no type definitions found, the identifier is a ts property, referred in an internal/external template
    // or is a reference in a decorator
    if (!typeDefs) {
        /*
         normally, the tsserver will consider non .ts files as external to the project
         however, we load .html files which we can handle with the Angular language service
         here we're only looking for definitions in a .ts source file
         we call the getSourceFile function which accesses a map of files, previously loaded by the tsserver
         at this point the map contains all .html files that we've included
         we have to ignore them, since the language service will attempt to parse them as .ts files
        */
        if (!definition.fileName.endsWith('.ts')) {
            return null;
        }
        const sourceFile = langServ.getProgram().getSourceFile(definition.fileName);
        if (!sourceFile) {
            return null;
        }
        const classDeclaration = sourceFile
            .statements
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            .filter((m => m.kind === tss.SyntaxKind.ClassDeclaration))
            .find(m => m.name.getText() === definition.containerName);
        // there must be at least one class declaration in the .ts file and the property must belong to it
        if (!classDeclaration) {
            return null;
        }
        const member = classDeclaration.members.find(m => m.name.getText() === definition.name);
        if (!(member === null || member === void 0 ? void 0 : member.name)) {
            return null;
        }
        typeDefs = getTypeDefinitions(langServ, definition.fileName, member.name.getStart() + 1);
    }
    if (typeDefs === null || typeDefs === void 0 ? void 0 : typeDefs.length) {
        return typeDefs[0];
    }
    return null;
};
exports.getTypeDefinitionAtPosition = getTypeDefinitionAtPosition;
const isMemberIgniteUI = (change, langServ, entryPath, matchPosition) => {
    var _a, _b;
    const prevChar = langServ.getProgram().getSourceFile(entryPath).getText().substr(matchPosition - 2, 1);
    if (prevChar === ')') {
        // methodCall().identifier
        matchPosition = (_b = (_a = langServ.getBraceMatchingAtPosition(entryPath, matchPosition - 2)[0]) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : matchPosition;
    }
    const typeDef = exports.getTypeDefinitionAtPosition(langServ, entryPath, matchPosition - 1);
    return !typeDef ? false : typeDef.fileName.includes(exports.IG_PACKAGE_NAME) && change.definedIn.indexOf(typeDef.name) !== -1;
};
exports.isMemberIgniteUI = isMemberIgniteUI;
//#endregion
